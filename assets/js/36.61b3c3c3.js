(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{445:function(t,n,e){"use strict";e.r(n);var r=e(2),a=Object(r.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"_10-合约继承"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-合约继承"}},[t._v("#")]),t._v(" 10.合约继承")]),t._v(" "),n("p",[t._v("实现继承的方式是通过复制包括多态的代码到子类来实现的。合约继承通过关键字 "),n("code",[t._v("is")]),t._v(" 来实现。由于 Solidity 继承的实现方案是代码拷贝，所以合约继承后，部署到网络时，将变成一个合约，代码将从父类拷贝到子类中。")]),t._v(" "),n("ul",[n("li",[t._v("修饰符可以继承")]),t._v(" "),n("li",[t._v("事件不可以继承，但是可以重载")]),t._v(" "),n("li",[n("code",[t._v("fallback")]),t._v(" 可以继承，但是需要保持原有的 "),n("code",[t._v("payable/nonpayable")])]),t._v(" "),n("li",[n("code",[t._v("receive")]),t._v(" 可以继承，但是需要保持原有的 "),n("code",[t._v("payable/nonpayable")])])]),t._v(" "),n("h2",{attrs:{id:"_1️⃣-使用-is-实现继承"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1️⃣-使用-is-实现继承"}},[t._v("#")]),t._v(" 1️⃣ 使用 "),n("code",[t._v("is")]),t._v(" 实现继承")]),t._v(" "),n("p",[t._v("当一个合约从多个合约继承时，在区块链上只有一个合约被创建，所有基类合约（或称为父合约）的代码被编译到创建的合约中。这意味着对基类合约函数的所有内部调用也只是使用内部函数调用（super.f（..）将使用 JUMP 跳转而不是消息调用）。")]),t._v(" "),n("ul",[n("li",[t._v("继承: "),n("strong",[t._v("派生合约")]),t._v("继承"),n("strong",[t._v("基础合约")]),t._v("的属性和方法")]),t._v(" "),n("li",[t._v("基础合约通常也被称为"),n("strong",[t._v("父合约")]),t._v("，派生合约通常也称作"),n("strong",[t._v("子合约")]),t._v("。")]),t._v(" "),n("li",[t._v('下面是: "男人"继承"人"的演示。')])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Person {\n    string internal name;\n    uint256 age; // 状态变量默认是internal权限\n\n    event Log(string funName);\n\n    modifier onlyOwner() virtual {\n        age = 1;\n        _;\n    }\n\n    fallback() external payable virtual {\n        emit Log("fallback by Person");\n    }\n\n    receive() external payable virtual {\n        emit Log("receive by Person");\n    }\n}\n\ncontract Man is Person {\n    constructor() {\n        name = "Anbang";\n        age = 18;\n    }\n\n    event Log(string funName, address _ads);\n\n    modifier onlyOwner() override {\n        age = 99;\n        _;\n    }\n\n    function getName() external view returns (string memory) {\n        return name;\n    }\n\n    function getAge() external view returns (uint256) {\n        return age;\n    }\n\n    function getAge2() external onlyOwner returns (uint256) {\n        return age;\n    }\n\n    // fallback 和 receive 继承的时候，必须保证 payable/nonpayable 状态不变。\n    // Overriding function changes state mutability from "payable" to "nonpayable".\n    // fallback() external override {\n    //     emit Log("fallback by man");\n    // }\n\n    fallback() external payable override {\n        emit Log("fallback by man");\n    }\n\n    receive() external payable override {\n        emit Log("receive by Man", msg.sender);\n    }\n}\n')])])]),n("ul",[n("li",[t._v("父合约必须写在子合约的前面，\n"),n("ul",[n("li",[t._v("否则会报错: "),n("code",[t._v("TypeError: Definition of base has to precede definition of derived contract")])])])])]),t._v(" "),n("h2",{attrs:{id:"_2️⃣-子类可以继承父类哪些数据"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2️⃣-子类可以继承父类哪些数据"}},[t._v("#")]),t._v(" 2️⃣ 子类可以继承父类哪些数据？")]),t._v(" "),n("p",[t._v("子类可以访问父类的权限修饰符只有："),n("code",[t._v("public/internal")]),t._v("，不能是 "),n("code",[t._v("external/private")]),t._v("。")]),t._v(" "),n("ul",[n("li",[t._v("如果父类的状态变量和函数是 "),n("code",[t._v("private")]),t._v(" 和 "),n("code",[t._v("external")]),t._v("，则子类不可以继承和访问。\n"),n("ul",[n("li",[t._v("如果子类调用父类 "),n("code",[t._v("external")]),t._v(" 修饰的函数，会报错:"),n("code",[t._v("Cannot call function via contract type name.")])])])])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Person {\n    string internal name;\n    uint256 age; // 状态变量默认是internal权限\n    uint256 public hand = 2;\n    uint256 private privateState = 99;\n\n    function publicFn() public pure returns (uint256) {\n        return 1;\n    }\n\n    function internalFn() internal pure returns (uint256) {\n        return 2;\n    }\n\n    function privateFn() private pure returns (uint256) {\n        return 3;\n    }\n}\n\ncontract Man is Person {\n    constructor() {\n        name = "Anbang";\n        age = 18;\n    }\n\n    function getInfo()\n        external\n        view\n        returns (\n            string memory,\n            uint256,\n            uint256\n        )\n    {\n        return (name, age, hand);\n        // privateState 不可以访问\n    }\n\n    function getPublicFn() external pure returns (uint256) {\n        return publicFn();\n    }\n\n    function getInternalFn() external pure returns (uint256) {\n        return internalFn();\n    }\n\n    // 不可以访问 privateFn 的方法\n    // function getPrivateFn() external pure returns (uint256) {\n    //     return privateFn(); // Undeclared identifier.\n    // }\n}\n')])])]),n("h2",{attrs:{id:"_3️⃣-多重继承中的重名"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3️⃣-多重继承中的重名"}},[t._v("#")]),t._v(" 3️⃣ 多重继承中的重名")]),t._v(" "),n("ul",[n("li",[t._v("一个合约同时继承 2 个合约时，这种情况叫多重继承")]),t._v(" "),n("li",[t._v("多重继承中不允许出现相同的"),n("strong",[t._v("函数名")]),t._v("、"),n("strong",[t._v("事件名")]),t._v("、"),n("strong",[t._v("修改器名")]),t._v("以及"),n("strong",[t._v("状态变量名")]),t._v("等。")])]),t._v(" "),n("p",[t._v("如下继承会报错，不允许编译:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract A {\n    string internal name;\n    event log();\n    modifier onlyOwner() {\n        _;\n    }\n\n    function test() internal {}\n}\n\ncontract B {\n    string internal name;\n    event log();\n    modifier onlyOwner() {\n        _;\n    }\n\n    function test() internal {}\n}\n\ncontract C is A, B {}\n")])])]),n("p",[t._v("多重继承函数中 getter 函数重名也不可以，如下是"),n("strong",[t._v("比较隐蔽的冲突情况")]),t._v("：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract A {\n    uint256 public data = 10;\n}\n\ncontract B {\n    // data函数之所以出错\n    // 是因为和 A 中状态变量 data 的 getter 函数重名。\n    function data() public returns (uint256) {\n        return 1;\n    }\n}\n\ncontract C is A, B {}\n")])])]),n("p",[t._v("当继承时合约出现了一下相同名字会被认为是一个错误：")]),t._v(" "),n("ul",[n("li",[t._v("函数 和 修改器/modifier 同名")]),t._v(" "),n("li",[t._v("函数 和 事件同名")]),t._v(" "),n("li",[t._v("事件和 修改器/modifier 同名")]),t._v(" "),n("li",[t._v("有一种例外情况，状态变量的 "),n("code",[t._v("getter")]),t._v(" 函数可以覆盖 "),n("code",[t._v("external")]),t._v(" 函数。")])]),t._v(" "),n("h2",{attrs:{id:"_4️⃣-重写函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4️⃣-重写函数"}},[t._v("#")]),t._v(" 4️⃣ 重写函数")]),t._v(" "),n("p",[t._v("solidity 引入了 "),n("code",[t._v("abstract")]),t._v(", "),n("code",[t._v("virtual")]),t._v(", "),n("code",[t._v("override")]),t._v(" 几个关键字，用于重写函数。父合约标记为 "),n("code",[t._v("virtual")]),t._v("函数可以在继承合约里重写(overridden)以更改他们的行为。重写的函数需要使用关键字 "),n("code",[t._v("override")]),t._v(" 修饰。")]),t._v(" "),n("p",[t._v("继承的方法重写需要注意的点:")]),t._v(" "),n("ul",[n("li",[t._v("父合约方法需要标示为"),n("strong",[t._v("可修改")]),t._v("，使用关键字 "),n("code",[t._v("virtual")]),t._v("，")]),t._v(" "),n("li",[t._v("子合约方法需要标示为"),n("strong",[t._v("覆盖")]),t._v("，使用关键词 "),n("code",[t._v("override")]),t._v(" "),n("ul",[n("li",[t._v("对于多重继承，如果有多个父合约有相同定义的函数， override 关键字后必须指定所有父合约名。")])])]),t._v(" "),n("li",[t._v("基础合约中可以包含没有实现代码的函数，也就是纯虚函数，那么基础合约必须声明为 "),n("code",[t._v("abstract")]),t._v("。")]),t._v(" "),n("li",[t._v("继承多个合约时，所有同名的可修改函数都需要重写")]),t._v(" "),n("li",[t._v("继承后重写合约方法，各个合约内的函数可见性需要一致")]),t._v(" "),n("li",[t._v("可变性可以按照以下顺序更改为更严格的一种： "),n("code",[t._v("nonpayable")]),t._v(" 可以被 "),n("code",[t._v("view")]),t._v(" 和"),n("code",[t._v("pure")]),t._v(" 覆盖。 "),n("code",[t._v("view")]),t._v(" 可以被 "),n("code",[t._v("pure")]),t._v(" 覆盖。 "),n("code",[t._v("payable")]),t._v("是一个例外，不能更改为任何其他可变性。")])]),t._v(" "),n("h3",{attrs:{id:"_1-virtual-和-override"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-virtual-和-override"}},[t._v("#")]),t._v(" 1.virtual 和 override")]),t._v(" "),n("p",[t._v("以下例子，B 继承 A，C 继承 B")]),t._v(" "),n("ul",[n("li",[t._v("A 是爷爷")]),t._v(" "),n("li",[t._v("B 是爸爸")]),t._v(" "),n("li",[t._v("C 是孙子")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract A {\n    function test1() public pure virtual returns (string memory) {\n        return "test1 from A";\n    }\n\n    // 使用 public 和 external 都可以\n    function test2() external pure virtual returns (string memory) {\n        return "test2 from A";\n    }\n\n    function test3() public pure virtual returns (string memory) {\n        return "test3 from A";\n    }\n}\n\ncontract B is A {\n    function test1() public pure virtual override returns (string memory) {\n        return "test1 from B";\n    }\n\n    function test2() external pure override returns (string memory) {\n        return "test2 from B";\n    }\n}\n\ncontract C is B {\n    function test1() public pure override returns (string memory) {\n        return "test1 from C";\n    }\n}\n')])])]),n("p",[t._v("对于多重继承，如果有多个父合约有相同定义的函数， "),n("code",[t._v("override")]),t._v(" 关键字后必须指定所有父合约名。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("pragma solidity >=0.7.0 <0.9.0;\n\ncontract Base1\n{\n    function foo() virtual public {}\n}\n\ncontract Base2\n{\n    function foo() virtual public {}\n}\n\ncontract Inherited is Base1, Base2\n{\n    // 继承自两个基类合约定义的foo(), 必须显示的指定 override\n    function foo() public override(Base1, Base2) {}\n}\n")])])]),n("p",[t._v("不过如果（重写的）函数继承自一个公共的父合约， "),n("code",[t._v("override")]),t._v(" 是可以不用显示指定的。 例如：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("pragma solidity >=0.7.0 <0.9.0;\n\ncontract A { function f() public pure{} }\ncontract B is A {}\ncontract C is A {}\n// 不用显示  override\ncontract D is B, C {}\n")])])]),n("p",[t._v("更正式地说，如果存在父合约是签名函数的所有重写路径的一部分，则不需要重写（直接或间接）从多个基础继承的函数，并且（1）父合约实现了该函数，从当前合约到父合约的路径都没有提到具有该签名的函数，或者（2）父合约没有实现该函数，并且存在从当前合约到该父合约的所有路径中，最多只能提及该函数。")]),t._v(" "),n("p",[t._v("从这个意义上说，签名函数的重写路径是通过继承图的路径，该路径始于所考虑的合约，并终止于提及具有该签名的函数的合约。")]),t._v(" "),n("p",[t._v("如果函数没有标记为 "),n("code",[t._v("virtual")]),t._v(" ，那么派生合约将不能更改函数的行为（即不能重写）。")]),t._v(" "),n("p",[t._v(".. note::"),n("code",[t._v("private")]),t._v(" 的函数是不可以标记为 "),n("code",[t._v("virtual")]),t._v(" 的。")]),t._v(" "),n("p",[t._v(".. note::除接口之外（因为接口会自动作为 "),n("code",[t._v("virtual")]),t._v(" ），没有实现的函数必须标记为"),n("code",[t._v("virtual")])]),t._v(" "),n("p",[t._v(".. note::从 Solidity 0.8.8 开始, 在重写接口函数时不再要求 "),n("code",[t._v("override")]),t._v("\n关键字，除非函数在多个父合约定义。")]),t._v(" "),n("p",[t._v("如果 getter 函数的参数和返回值都和外部函数一致时，外部（external）函数是可以被 public 的状态变量被重写的，例如：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("\n    pragma solidity >=0.7.0 <0.9.0;\n\n    contract A\n    {\n        function f() external view virtual returns(uint) { return 5; }\n    }\n\n    contract B is A\n    {\n        uint public override f;\n    }\n\n")])])]),n("p",[t._v("⚠️ : 尽管 public 的状态变量可以重写外部函数，但是 public 的状态变量不能被重写。")]),t._v(" "),n("h3",{attrs:{id:"_2-abstract-抽象合约"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-abstract-抽象合约"}},[t._v("#")]),t._v(" 2.abstract（抽象合约）")]),t._v(" "),n("p",[t._v("基础合约中可以包含没有实现代码的函数，也就是纯虚函数，那么基础合约必须声明为 "),n("code",[t._v("abstract")]),t._v("。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nabstract contract IERC20 {\n    function transfer() external virtual returns (bool);\n}\n\ncontract ERC20 is IERC20 {\n    function transfer() external pure override returns (bool) {\n        return true;\n    }\n}\n")])])]),n("p",[t._v("扩展: 这里的 "),n("code",[t._v("abstract")]),t._v("，也可以使用 "),n("code",[t._v("interface")]),t._v(" 来解决。 更多 "),n("code",[t._v("interface")]),t._v(" 内容，请参考 "),n("RouterLink",{attrs:{to:"/source/13.interface.html"}},[t._v("interface:接口")]),t._v(" 详细阅读。")],1),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IERC20 {\n    function transfer() external returns (bool);\n}\n\ncontract ERC20 is IERC20 {\n    function transfer() external pure returns (bool) {\n        return true;\n    }\n}\n")])])]),n("h2",{attrs:{id:"_5️⃣-多级继承的代码书写顺序-线性化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5️⃣-多级继承的代码书写顺序-线性化"}},[t._v("#")]),t._v(" 5️⃣ 多级继承的代码书写顺序（线性化）")]),t._v(" "),n("p",[t._v("Solidity 语言的多重继承采用线性继承方式。继承顺序很重要，判断顺序的一个简单规则是按照"),n("strong",[t._v("从“最类似基类”到“最多派生”的顺序指定基类")]),t._v("。")]),t._v(" "),n("p",[t._v("原则："),n("strong",[t._v("先写基础合约，再写派生合约。")])]),t._v(" "),n("p",[n("strong",[t._v("小技巧：可以先画继承逻辑图，然后按照从上到下，从左到右的顺序来写合约；")])]),t._v(" "),n("p",[t._v("上面 "),n("strong",[t._v("virtual 和 override")]),t._v(" 的介绍例子中，合约继承逻辑图如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("/**\nA\n|\nB\n|\nC\n */\n")])])]),n("p",[t._v("B 继承 A，C 继承 B。所以写的时候顺序是: "),n("code",[t._v("A => B => C")])]),t._v(" "),n("h3",{attrs:{id:"_1-继承案例一"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-继承案例一"}},[t._v("#")]),t._v(" 1.继承案例一")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("/**\n B   A\n  \\ /\n   C\n */\n")])])]),n("p",[t._v("C 继承 A 和 B。")]),t._v(" "),n("p",[t._v("写的时候顺序是: "),n("code",[t._v("A > B > C")]),t._v(" / "),n("code",[t._v("B > A > C")]),t._v(" 都是可以的")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract A {\n    function test1() public pure virtual returns (string memory) {\n        return "test1 from A";\n    }\n}\n\ncontract B {\n    function test2() public pure virtual returns (string memory) {\n        return "test2 from B";\n    }\n}\n\ncontract C is A, B {\n    function test3() public pure returns (string memory) {\n        return "test3 from C";\n    }\n}\n')])])]),n("h3",{attrs:{id:"_2-继承案例二"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-继承案例二"}},[t._v("#")]),t._v(" 2.继承案例二")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("/**\n    A\n  / |\nB   |\n  \\ |\n    C\n */\n")])])]),n("p",[t._v("B 继承 A，C 继承 A 和 B。"),n("strong",[t._v("注意:这里是 C 继承 A 和 B，不是 C 继承 B 和 A")]),t._v("。")]),t._v(" "),n("p",[t._v("写的时候顺序是: "),n("code",[t._v("A > B > C")])]),t._v(" "),n("p",[n("strong",[t._v("代码如下:")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract A {\n    function test1() public pure virtual returns (string memory) {\n        return "test1 from A";\n    }\n\n    // 使用 public 和 external 都可以\n    function test2() external pure virtual returns (string memory) {\n        return "test2 from A";\n    }\n\n    function test3() public pure virtual returns (string memory) {\n        return "test3 from A";\n    }\n}\n\ncontract B is A {\n    function test1() public pure virtual override returns (string memory) {\n        return "test1 from B";\n    }\n\n    function test2() external pure virtual override returns (string memory) {\n        return "test2 from B";\n    }\n}\n\n// 这里必须是 contract C is A, B\n// 不能使用 contract C is B, A\ncontract C is A, B {\n    function test1() public pure override(A, B) returns (string memory) {\n        return "test1 from C";\n    }\n\n    // overrid内参数顺序无所谓，\n    // C 内必须重写 A 和 B，否则会报错\n    function test2() public pure override(B, A) returns (string memory) {\n        return "test1 from C";\n    }\n}\n')])])]),n("ul",[n("li",[n("strong",[t._v("C 继承 A 和 B 时候，所有 A 和 B 函数相同名字的方法，都需要重写。")]),t._v(" "),n("ul",[n("li",[t._v("否则会报错:")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('Derived contract must override function "functionName".\nTwo or more base classes define function with same name and parameter types.\n')])])])]),t._v(" "),n("li",[n("strong",[t._v("多重继承时候，需要先写基础合约，再写派生合约")]),t._v(" "),n("ul",[n("li",[t._v("写合约 C 的时候，必须写成"),n("code",[t._v("contract C is A, B")]),t._v("，不能写"),n("code",[t._v("contract C is B, A")])]),t._v(" "),n("li",[t._v("否则会报错:"),n("code",[t._v("TypeError: Linearization of inheritance graph impossible")]),t._v("。")])])])]),t._v(" "),n("h3",{attrs:{id:"_3-继承案例三"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-继承案例三"}},[t._v("#")]),t._v(" 3.继承案例三")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("/**\n    A\n  / |\nB   |\n  \\ |\n    C\n    |\n    D\n */\n")])])]),n("p",[t._v("B 继承 A，C 继承 A 和 B，D 继承 C。（"),n("strong",[t._v("注意:这里是 C 继承 A 和 B，不是 C 继承 B 和 A")]),t._v("），所以写的时候顺序是: "),n("code",[t._v("A > B > C > D")])]),t._v(" "),n("p",[t._v("D 继承 C 时候，没有同名函数的冲突，所以 test1 和 test2 随便是否重写。")]),t._v(" "),n("p",[n("strong",[t._v("代码如下")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract A {\n    function test1() public pure virtual returns (string memory) {\n        return "test1 from A";\n    }\n\n    // 使用 public 和 external 都可以\n    function test2() external pure virtual returns (string memory) {\n        return "test2 from A";\n    }\n\n    function test3() public pure virtual returns (string memory) {\n        return "test3 from A";\n    }\n}\n\ncontract B is A {\n    function test1() public pure virtual override returns (string memory) {\n        return "test1 from B";\n    }\n\n    function test2() external pure virtual override returns (string memory) {\n        return "test2 from B";\n    }\n}\n\n// 这里必须是 contract C is A, B\n// 不能使用 contract C is B, A\ncontract C is A, B {\n    function test1()\n        public\n        pure\n        virtual\n        override(A, B)\n        returns (string memory)\n    {\n        return "test1 from C";\n    }\n\n    // overrid内参数顺序无所谓，\n    function test2()\n        public\n        pure\n        virtual\n        override(B, A)\n        returns (string memory)\n    {\n        return "test1 from C";\n    }\n}\n\ncontract D is C {\n    function test1() public pure override returns (string memory) {\n        return "test1 from D";\n    }\n}\n')])])]),n("h3",{attrs:{id:"_4-继承案例四"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-继承案例四"}},[t._v("#")]),t._v(" 4.继承案例四")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("/**\n     A\n   / |\n  /  |\nB    C\n  \\  |\n   \\ D\n    \\|\n     E\n */\n")])])]),n("p",[t._v("B 继承 A，C 继承 A，D 继承 C，E 继承 B 和 D。所以写的时候顺序是: "),n("code",[t._v("A > B > C > D")])]),t._v(" "),n("p",[n("strong",[t._v("例子如下:")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract A {\n    function test1() public pure virtual returns (string memory) {\n        return "test1 from A";\n    }\n\n    // 使用 public 和 external 都可以\n    function test2() external pure virtual returns (string memory) {\n        return "test2 from A";\n    }\n\n    function test3() public pure virtual returns (string memory) {\n        return "test3 from A";\n    }\n}\n\ncontract B is A {\n    function test1() public pure virtual override returns (string memory) {\n        return "test1 from B";\n    }\n\n    function test2() external pure virtual override returns (string memory) {\n        return "test2 from B";\n    }\n}\n\ncontract C is A {\n    function test1() public pure virtual override returns (string memory) {\n        return "test1 from C";\n    }\n}\n\ncontract D is C {\n    function test1() public pure virtual override returns (string memory) {\n        return "test1 from D";\n    }\n}\n\ncontract D is B, D {\n    function test1() public pure override(B, D) returns (string memory) {\n        return "test1 from E";\n    }\n\n    // 必须要重写 test2 ，因为此时 B 和 D 内都有test2方法，但是D内继承A的test2方法，冲突了。\n    // 需要要写  override(B, A)，不能写 override(B, D)，否则会报如下错误\n    // Function needs to specify overridden contract "A".\n    // Invalid contract specified in override list: "D".\n\n    // 下面是错误的写法\n    // function test2() public pure override(B, D) returns (string memory) {\n\n    // 下面是正确的写法\n    function test2() public pure override(B, A) returns (string memory) {\n        return "test2 from E";\n    }\n}\n')])])]),n("p",[t._v("E 内必须要重写 test2 ，因为此时 B 和 D 内都有 test2 方法，但是 D 内继承 A 的 test2 方法，需要要写 override(B, A)，不能写 override(B, D)，否则会报错误:")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('Function needs to specify overridden contract "A".\nInvalid contract specified in override list: "D".\n')])])]),n("h2",{attrs:{id:"_6️⃣-继承中两种构造函数传参方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6️⃣-继承中两种构造函数传参方式"}},[t._v("#")]),t._v(" 6️⃣ 继承中两种构造函数传参方式")]),t._v(" "),n("p",[t._v("继承的父合约，如果有构造函数并且需要传入参数，我们有以下几种方法进行参数传入")]),t._v(" "),n("h3",{attrs:{id:"两种传参方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#两种传参方法"}},[t._v("#")]),t._v(" 两种传参方法")]),t._v(" "),n("ul",[n("li",[n("strong",[t._v("方法 1")]),t._v(": 固定值传参。（该方式不能在部署时动态输入）。\n"),n("ul",[n("li",[t._v("如果我们已经知道基类初始化参数，那么就可以在派生类的继承声明中，直接传递参数给基类的构造函数。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('contract C is A("n"),B("v") {}\n')])])])]),t._v(" "),n("li",[n("strong",[t._v("方法 2")]),t._v(": 动态传参\n"),n("ul",[n("li",[t._v("如果我们需要在部署时或者运行时，由调用方传递基类初始化参数。在这种情况下，我们需要编写一个新的构造函数，传递参数给基类。")]),t._v(" "),n("li",[t._v("部署子合约的时候，传入参数到构造函数，该种方法是动态的值，可以部署的时候动态输入")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("contract D is A {\n  constructor(string memory _name) A(_name) {}\n}\n")])])])]),t._v(" "),n("li",[n("strong",[t._v("混写")]),t._v(": 方法 1 和方法 2 可以混合使用"),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('contract E is A, B("EEEEEEEEEEEEE") {\n  constructor(string memory _name) A(_name) {}\n}\n')])])])])]),t._v(" "),n("p",[n("strong",[t._v("例子如下:")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract A {\n    string public nameA;\n\n    constructor(string memory _name) {\n        nameA = _name;\n    }\n}\n\ncontract B {\n    string public nameB;\n\n    constructor(string memory _name) {\n        nameB = _name;\n    }\n}\n\n// 方法1: 继承时候直接传入参数，该种方法是固定值，不能动态输入\ncontract C is A("Name From C") {\n\n}\n\n// 方法2: 部署子合约的时候，传入参数到构造函数，该种方法是动态的值，可以部署的时候动态输入\ncontract D is A {\n    constructor(string memory _name) A(_name) {}\n}\n\n//  混合使用\ncontract E is A, B("EEEEEEEEEEEEE") {\n    constructor(string memory _name) A(_name) {}\n}\n')])])]),n("h2",{attrs:{id:"_7️⃣-继承中构造函数的执行顺序"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_7️⃣-继承中构造函数的执行顺序"}},[t._v("#")]),t._v(" 7️⃣ 继承中构造函数的执行顺序")]),t._v(" "),n("p",[t._v("多重继承中，构造函数的执行会按照定义时的继承顺序进行，与构造函数中定义顺序无关。")]),t._v(" "),n("p",[t._v("原则: "),n("strong",[t._v("构造函数的执行顺序按照继承的顺序。")])]),t._v(" "),n("p",[n("strong",[t._v("例子:")])]),t._v(" "),n("ol",[n("li",[t._v("如下是先执行 A，再执行 B")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('contract E is A, B("EEEEEEEEEEEEE") {\n    constructor(string memory _name) A(_name) {}\n}\n')])])]),n("ol",{attrs:{start:"2"}},[n("li",[t._v("如下是先执行 B，再执行 A")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('contract E is B("EEEEEEEEEEEEE"),A {\n    constructor(string memory _name) A(_name) {}\n}\n')])])]),n("p",[n("strong",[t._v("例子如下")]),t._v(":")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract A {\n    event logA(string);\n\n    constructor(string memory _name) {\n        emit logA(_name);\n    }\n}\n\ncontract B {\n    event logB(string);\n\n    constructor(string memory _name) {\n        emit logB(_name);\n    }\n}\n\n//  混合使用\ncontract E is A, B("EEE") {\n    constructor(string memory _name) A(_name) {}\n}\n\ncontract F is B("FFF"), A {\n    constructor(string memory _name) A(_name) {}\n}\n')])])]),n("p",[t._v("部署 E 时候，输入 "),n("code",[t._v("Anbang")]),t._v("，输出的 log 如下:"),n("strong",[t._v("先执行 A，再执行 B")])]),t._v(" "),n("div",{staticClass:"language-json extra-class"},[n("pre",{pre:!0,attrs:{class:"language-json"}},[n("code",[n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),n("span",{pre:!0,attrs:{class:"token property"}},[t._v('"from"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0xed27012c24FDa47A661De241c4030ecB9D18a76d"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t\t"),n("span",{pre:!0,attrs:{class:"token property"}},[t._v('"topic"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0xb911c6b2723a9b89f3c8a0ce3f2dca6648150807aa6d6959fb18fa31748efcee"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t\t"),n("span",{pre:!0,attrs:{class:"token property"}},[t._v('"event"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"logA"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t\t"),n("span",{pre:!0,attrs:{class:"token property"}},[t._v('"args"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\t"),n("span",{pre:!0,attrs:{class:"token property"}},[t._v('"0"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Anbang"')]),t._v("\n\t\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),n("span",{pre:!0,attrs:{class:"token property"}},[t._v('"from"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0xed27012c24FDa47A661De241c4030ecB9D18a76d"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t\t"),n("span",{pre:!0,attrs:{class:"token property"}},[t._v('"topic"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x2a205cc759862a651d0a138a2245cac3f4b3214b93707a9d0fe4eb716f66f786"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t\t"),n("span",{pre:!0,attrs:{class:"token property"}},[t._v('"event"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"logB"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t\t"),n("span",{pre:!0,attrs:{class:"token property"}},[t._v('"args"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\t"),n("span",{pre:!0,attrs:{class:"token property"}},[t._v('"0"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"EEE"')]),t._v("\n\t\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),n("p",[t._v("部署 F 时候，输入 "),n("code",[t._v("Anbang")]),t._v("，输出的 log 如下:"),n("strong",[t._v("先执行 B，再执行 A")])]),t._v(" "),n("div",{staticClass:"language-json extra-class"},[n("pre",{pre:!0,attrs:{class:"language-json"}},[n("code",[n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),n("span",{pre:!0,attrs:{class:"token property"}},[t._v('"from"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x3D42AD7A3AEFDf99038Cd61053913CFCA4944b95"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t\t"),n("span",{pre:!0,attrs:{class:"token property"}},[t._v('"topic"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x2a205cc759862a651d0a138a2245cac3f4b3214b93707a9d0fe4eb716f66f786"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t\t"),n("span",{pre:!0,attrs:{class:"token property"}},[t._v('"event"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"logB"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t\t"),n("span",{pre:!0,attrs:{class:"token property"}},[t._v('"args"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\t"),n("span",{pre:!0,attrs:{class:"token property"}},[t._v('"0"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"FFF"')]),t._v("\n\t\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),n("span",{pre:!0,attrs:{class:"token property"}},[t._v('"from"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x3D42AD7A3AEFDf99038Cd61053913CFCA4944b95"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t\t"),n("span",{pre:!0,attrs:{class:"token property"}},[t._v('"topic"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0xb911c6b2723a9b89f3c8a0ce3f2dca6648150807aa6d6959fb18fa31748efcee"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t\t"),n("span",{pre:!0,attrs:{class:"token property"}},[t._v('"event"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"logA"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t\t"),n("span",{pre:!0,attrs:{class:"token property"}},[t._v('"args"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\t"),n("span",{pre:!0,attrs:{class:"token property"}},[t._v('"0"')]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Anbang"')]),t._v("\n\t\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),n("h2",{attrs:{id:"_8️⃣-两种子合约调用父合约的方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_8️⃣-两种子合约调用父合约的方法"}},[t._v("#")]),t._v(" 8️⃣ 两种子合约调用父合约的方法")]),t._v(" "),n("p",[t._v("有两种方法可以调用")]),t._v(" "),n("ol",[n("li",[t._v("直接使用合约名调用 "),n("code",[t._v("ParentContractName.functionName()")]),t._v(";")]),t._v(" "),n("li",[t._v("使用 super 关键字 "),n("code",[t._v("super.functionName()")]),t._v(" "),n("ul",[n("li",[t._v("super 会自动寻找父合约，并执行对应的方法；")]),t._v(" "),n("li",[n("strong",[t._v("如果是多个父级，那么父级都会执行。但有时候又不会，执行顺序的原理，这些需要详细的了解")])]),t._v(" "),n("li",[t._v("如果 super 导致 2 个父级同时触发同一个爷爷合约的相同方法；则爷爷的方法只执行一次。一个合约的同一个方法只会执行一次，不会执行多次。")])])])]),t._v(" "),n("h3",{attrs:{id:"_1-直接使用合约名调用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-直接使用合约名调用"}},[t._v("#")]),t._v(" 1.直接使用合约名调用")]),t._v(" "),n("p",[t._v("执行顺序：像水中的冒泡一样，由下向上进行执行。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract A {\n    event Log(string msg);\n\n    function test1() public virtual {\n        emit Log("A.test1");\n    }\n}\n\ncontract B is A {\n    function test1() public virtual override {\n        emit Log("B.test1");\n        A.test1();\n    }\n}\n')])])]),n("p",[t._v("上面的例子执行顺序是")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("1. B.test1\n2. A.test1\n")])])]),n("h3",{attrs:{id:"_2-使用-super-关键字调用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-使用-super-关键字调用"}},[t._v("#")]),t._v(" 2.使用 super 关键字调用")]),t._v(" "),n("h4",{attrs:{id:"基础继承"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#基础继承"}},[t._v("#")]),t._v(" 基础继承")]),t._v(" "),n("p",[t._v("执行顺序：像水中的冒泡一样，由下向上进行执行。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract A {\n    event Log(string msg);\n\n    function test1() public virtual {\n        emit Log("A.test1");\n    }\n}\n\ncontract C is A {\n    function test1() public virtual override {\n        emit Log("C.test1");\n        super.test1();\n    }\n}\n')])])]),n("p",[t._v("上面的例子执行顺序是")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("1. C.test1\n2. A.test1\n")])])]),n("h4",{attrs:{id:"多重继承"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#多重继承"}},[t._v("#")]),t._v(" 多重继承")]),t._v(" "),n("p",[t._v("写一个如下逻辑的继承")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("/**\n   A\n /   \\\nB     C\n \\   /\n   D\n */\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract A {\n    event Log(string msg);\n\n    function test1() public virtual {\n        emit Log("A.test1");\n    }\n}\n\ncontract B is A {\n    function test1() public virtual override {\n        emit Log("B.test1");\n        A.test1();\n    }\n}\n\ncontract C is A {\n    function test1() public virtual override {\n        emit Log("C.test1");\n        super.test1();\n    }\n}\n\ncontract D is B, C {\n    function test1() public override(B, C) {\n        emit Log("D.test1");\n        // 因为 B 和 C 都是 D 的父级，所以B和C都会执行\n        super.test1();\n    }\n}\n')])])]),n("p",[t._v("执行顺序：像水中的冒泡一样，由下向上进行执行。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("1. D.test1\n1. C.test1\n1. B.test1\n1. A.test1 (这里 A 只执行一次)\n")])])]),n("p",[n("strong",[t._v("警告")]),t._v(" : 为什么先输出 C，后输出 B ?")]),t._v(" "),n("p",[t._v("上面的例子，如果代码中 B 和 C 换顺序，还是执行的 "),n("code",[t._v("DCBA")]),t._v("。开始怀疑和函数名字的 hash 结果顺序有关系，看完下面的继续研究代码，可以得出结论，复杂继承的时候，supper 方式就像一个疯子一样没有规律可言。我们能做的就是避开使用它。")]),t._v(" "),n("h2",{attrs:{id:"_9️⃣-多重继承合约不要使用-supper"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_9️⃣-多重继承合约不要使用-supper"}},[t._v("#")]),t._v(" 9️⃣ 多重继承合约不要使用 supper")]),t._v(" "),n("p",[t._v("写一个如下逻辑的继承")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("/**\n   A\n /   \\\nB     C\n| \\  /|\n|  \\/ |\n|  /\\ |\n| /  \\|\nD     E\n */\n")])])]),n("p",[n("strong",[t._v("代码如下")]),t._v(":")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract A {\n    event Log(string msg);\n\n    // 继承后重写合约方法，可见性需要一致\n    function test1() public virtual {\n        emit Log("A.test1");\n    }\n}\n\ncontract B is A {\n    // 执行 B.test1 后\n    // 1. B.test1\n    // 2. A.test1\n    function test1() public virtual override {\n        emit Log("B.test1");\n        A.test1();\n    }\n}\n\ncontract C is A {\n    // 执行 C.test1 后\n    // 1. C.test1\n    // 2. A.test1\n    function test1() public virtual override {\n        emit Log("C.test1");\n        super.test1();\n    }\n}\n\ncontract D is B, C {\n    // 执行 D.test1 后\n    // 1. D.test1\n    // 2. C.test1\n    // 3. B.test1\n    // 4. A.test1\n    function test1() public override(B, C) {\n        emit Log("D.test1");\n        super.test1();\n    }\n}\n\n// 代码 contract D is B, C 改成 contract E is C, B 后 , C.test1 不执行了。\ncontract E is C, B {\n    // 执行 E.test1 后\n    // 1. E.test1\n    // 3. B.test1\n    // 4. A.test1\n    function test1() public override(B, C) {\n        emit Log("E.test1");\n        // B 和 C 都是 E 的父级，为啥B执行，而C不执行\n        super.test1();\n    }\n}\n')])])]),n("p",[n("strong",[t._v("疑问: 执行 E.test1 后,输出如下结果，这是没有任何规律的，并且丢失数据")]),t._v("，在这种多重继承的时候，调用父合约不要 supper，直接使用合约名字是最稳妥的办法，切记切记。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("1. E.test1\n3. B.test1\n4. A.test1\n")])])]),n("h2",{attrs:{id:"🆗-实战应用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#🆗-实战应用"}},[t._v("#")]),t._v(" 🆗 实战应用")]),t._v(" "),n("p",[t._v("下面的例子进行了详细的说明。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('    // SPDX-License-Identifier: GPL-3.0\n    pragma solidity >=0.7.0 <0.9.0;\n\n    contract Owned {\n        constructor() public { owner = payable(msg.sender); }\n        address payable owner;\n    }\n\n    // 使用 is 从另一个合约派生。派生合约可以访问所有非私有成员，包括内部（internal）函数和状态变量，\n    // 但无法通过 this 来外部访问。\n    contract Destructible is Owned {\n\n     // 关键字`virtual`表示该函数可以在派生类中“overriding”。\n\n         function destroy() virtual public { if (msg.sender == owner)\nselfdestruct(owner); } }\n\n    // 这些抽象合约仅用于给编译器提供接口。\n    // 注意函数没有函数体。\n    // 如果一个合约没有实现所有函数，则只能用作接口。\n    abstract contract Config {\n        function lookup(uint id) public virtual returns (address adr);\n    }\n\n    abstract contract NameReg {\n        function register(bytes32 name) public virtual;\n        function unregister() public virtual;\n     }\n\n    // 可以多重继承。请注意，owned 也是 Destructible 的基类，\n    // 但只有一个 owned 实例（就像 C++ 中的虚拟继承）。\n    contract Named is Owned, Destructible {\n        constructor(bytes32 name) {\n            Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);\n            NameReg(config.lookup(1)).register(name);\n        }\n\n        // 函数可以被另一个具有相同名称和相同数量/类型输入的函数重载。\n        // 如果重载函数有不同类型的输出参数，会导致错误。\n        // 本地和基于消息的函数调用都会考虑这些重载。\n\n//如果要覆盖函数，则需要使用 `override` 关键字。\n如果您想再次覆盖此函数，则需要再次指定`virtual`关键字。\n\n        function destroy() public virtual override {\n            if (msg.sender == owner) {\n                Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);\n                NameReg(config.lookup(1)).unregister();\n                // 仍然可以调用特定的重载函数。\n                Destructible.destroy();\n            }\n        }\n    }\n\n    // 如果构造函数接受参数，\n    // 则需要在声明（合约的构造函数）时提供，\n    // 或在派生合约的构造函数位置以修改器调用风格提供（见下文）。\n    contract PriceFeed is Owned, Destructible, Named("GoldFeed") {\n        function updateInfo(uint newInfo) public {\n            if (msg.sender == owner) info = newInfo;\n        }\n\n        // Here, we only specify `override` and not `virtual`.\n        // This means that contracts deriving from `PriceFeed`\n        // cannot change the behaviour of `destroy` anymore.\n        function destroy() public override(Destructible, Named) { Named.destroy(); }\n\n        function get() public view returns(uint r) { return info; }\n\n        uint info;\n    }\n')])])]),n("p",[t._v("注意，在上边的代码中，我们调用 "),n("code",[t._v("Destructible.destroy()")]),t._v('\n来"转发"销毁请求。 这样做法是有问题的，在下面的例子中可以看到：')]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("\n    // SPDX-License-Identifier: GPL-3.0\n    pragma solidity >=0.7.0 <0.9.0;\n\n    contract owned {\n        constructor() { owner = payable(msg.sender); }\n        address owner;\n    }\n\n    contract Destructible is owned {\n        function destroy() public virtual {\n            if (msg.sender == owner) selfdestruct(owner);\n        }\n    }\n\n    contract Base1 is Destructible {\n        function destroy() public virtual override  {\n            /* 清除操作 1 */\n            Destructible.destroy();\n        }\n    }\n\n    contract Base2 is Destructible {\n        function destroy() public { /* 清除操作 2 */ Destructible.destroy(); }\n    }\n\n    contract Final is Base1, Base2 {\n        function destroy() public override(Base1, Base2) { Base2.destroy(); }\n    }\n\n")])])]),n("p",[t._v("。 解决此问题的方法是使用 super：")]),t._v(" "),n("p",[t._v("调用 "),n("code",[t._v("Final.destroy()")]),t._v(" 时会调用 "),n("code",[t._v("Base2.destroy")]),t._v("，\n因为我们在最终重写中显式指定了它。 但是此函数将绕过 "),n("code",[t._v("Base1.destroy")]),t._v(",\n解决这个问题的方法是使用 "),n("code",[t._v("super")]),t._v("：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("\n    // SPDX-License-Identifier: GPL-3.0\n    pragma solidity >=0.7.0 <0.9.0;\n\n    contract owned {\n        constructor() { owner = payable(msg.sender); }\n        address owner;\n    }\n\n    contract Destructible is owned {\n        function destroy() virtual public {\n            if (msg.sender == owner) selfdestruct(owner);\n        }\n    }\n\n    contract Base1 is Destructible {\n        function destroy() public virtual override { /* 清除操作 1 */ super.destroy(); }\n    }\n\n\n    contract Base2 is Destructible {\n        function destroy() public  virtual override { /* 清除操作 2 */ super.destroy(); }\n    }\n\n    contract Final is Base1, Base2 {\n        function destroy() public override(Base1, Base2) { super.destroy(); }\n    }\n\n")])])]),n("p",[t._v("如果 "),n("code",[t._v("Base2")]),t._v(" 调用 "),n("code",[t._v("super")]),t._v(" 的函数，它不会简单在其基类合约上调用该函数。\n相反，它在最终的继承关系图谱的下一个基类合约中调用这个函数，所以它会调用\n"),n("code",[t._v("Base1.destroy()")]),t._v(" （注意最终的继承序列是------从最终派生合约开始：Final,\nBase2, Base1, Destructible, ownerd）。 在类中使用 super\n调用的实际函数在当前类的上下文中是未知的，尽管它的类型是已知的。\n这与普通的虚拟方法查找类似。")]),t._v(" "),n("h2",{attrs:{id:"️⃣-问答题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#️⃣-问答题"}},[t._v("#")]),t._v(" #️⃣ 问答题")]),t._v(" "),n("ul",[n("li",[t._v("继承如何实现？\n"),n("ul",[n("li",[t._v("使用 "),n("code",[t._v("is")]),t._v(" 实现继承")]),t._v(" "),n("li",[t._v("继承: "),n("strong",[t._v("派生合约")]),t._v("继承"),n("strong",[t._v("基础合约")]),t._v("的属性和方法")]),t._v(" "),n("li",[t._v("基础合约通常也被称为"),n("strong",[t._v("父合约")]),t._v("，派生合约通常也称作"),n("strong",[t._v("子合约")]),t._v("。")]),t._v(" "),n("li",[t._v("父合约必须写在子合约的前面，否则会报错")])])]),t._v(" "),n("li",[t._v("子类可以继承父类哪些数据？\n"),n("ul",[n("li",[t._v("子类可以访问父类的权限修饰符只有："),n("code",[t._v("public/internal")]),t._v("，不能是 "),n("code",[t._v("external/private")]),t._v("。")])])]),t._v(" "),n("li",[t._v("多重继承中哪些属于重名？\n"),n("ul",[n("li",[t._v("一个合约同时继承 2 个合约时，这种情况叫多重继承")]),t._v(" "),n("li",[t._v("多重继承中不允许出现相同的"),n("strong",[t._v("函数名")]),t._v("、"),n("strong",[t._v("事件名")]),t._v("、"),n("strong",[t._v("修改器名")]),t._v("以及"),n("strong",[t._v("状态变量名")]),t._v("等。多重继承函数中 getter 函数重名也不可以。")]),t._v(" "),n("li",[t._v("当继承时合约出现了一下相同名字会被认为是一个错误：\n"),n("ul",[n("li",[t._v("函数 和 修改器/modifier 同名")]),t._v(" "),n("li",[t._v("函数 和 事件同名")]),t._v(" "),n("li",[t._v("事件和 修改器/modifier 同名")]),t._v(" "),n("li",[t._v("有一种例外情况，状态变量的 "),n("code",[t._v("getter")]),t._v(" 函数可以覆盖 "),n("code",[t._v("external")]),t._v(" 函数。")])])])])]),t._v(" "),n("li",[t._v("如何重写函数？\n"),n("ul",[n("li",[t._v("solidity 引入了 "),n("code",[t._v("abstract")]),t._v(", "),n("code",[t._v("virtual")]),t._v(", "),n("code",[t._v("override")]),t._v(" 几个关键字，用于重写函数。")]),t._v(" "),n("li",[t._v("父合约方法需要标示为"),n("strong",[t._v("可修改")]),t._v("，使用关键字 "),n("code",[t._v("virtual")]),t._v("，")]),t._v(" "),n("li",[t._v("子合约方法需要标示为"),n("strong",[t._v("覆盖")]),t._v("，使用关键词 "),n("code",[t._v("override")]),t._v(" "),n("ul",[n("li",[t._v("对于多重继承，如果有多个父合约有相同定义的函数， override 关键字后必须指定所有父合约名。")])])]),t._v(" "),n("li",[t._v("基础合约中可以包含没有实现代码的函数，也就是纯虚函数，那么基础合约必须声明为 "),n("code",[t._v("abstract")]),t._v("。（"),n("code",[t._v("abstract")]),t._v("，也可以使用 "),n("code",[t._v("interface")]),t._v(" 来解决。）")]),t._v(" "),n("li",[t._v("继承多个合约时，所有同名的可修改函数都需要重写")]),t._v(" "),n("li",[t._v("继承后重写合约方法，各个合约内的函数可见性需要一致")]),t._v(" "),n("li",[t._v("可变性可以按照以下顺序更改为更严格的一种： "),n("code",[t._v("nonpayable")]),t._v(" 可以被 "),n("code",[t._v("view")]),t._v(" 和"),n("code",[t._v("pure")]),t._v(" 覆盖。 "),n("code",[t._v("view")]),t._v(" 可以被 "),n("code",[t._v("pure")]),t._v(" 覆盖。 "),n("code",[t._v("payable")]),t._v("是一个例外，不能更改为任何其他可变性。")])])]),t._v(" "),n("li",[t._v("多级继承的代码书写顺序？\n"),n("ul",[n("li",[t._v("按照从“最类似基类”到“最多派生”的顺序指定基类。")]),t._v(" "),n("li",[t._v("原则：先写基础合约，再写派生合约。")]),t._v(" "),n("li",[t._v("小技巧：可以先画继承逻辑图，然后按照从上到下，从左到右的顺序来写合约；")])])]),t._v(" "),n("li",[t._v("继承中两种构造函数传参方式。\n"),n("ul",[n("li",[n("strong",[t._v("方法 1")]),t._v(": 固定值传参。（该方式不能在部署时动态输入）。\n"),n("ul",[n("li",[t._v("如果我们已经知道基类初始化参数，那么就可以在派生类的继承声明中，直接传递参数给基类的构造函数。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('contract C is A("n"),B("v") {}\n')])])])]),t._v(" "),n("li",[n("strong",[t._v("方法 2")]),t._v(": 动态传参\n"),n("ul",[n("li",[t._v("如果我们需要在部署时或者运行时，由调用方传递基类初始化参数。在这种情况下，我们需要编写一个新的构造函数，传递参数给基类。")]),t._v(" "),n("li",[t._v("部署子合约的时候，传入参数到构造函数，该种方法是动态的值，可以部署的时候动态输入")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("contract D is A {\n  constructor(string memory _name) A(_name) {}\n}\n")])])])]),t._v(" "),n("li",[n("strong",[t._v("混写")]),t._v(": 方法 1 和方法 2 可以混合使用"),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('contract E is A, B("EEEEEEEEEEEEE") {\n  constructor(string memory _name) A(_name) {}\n}\n')])])])])])]),t._v(" "),n("li",[t._v("继承中构造函数的执行顺序\n"),n("ul",[n("li",[t._v("多重继承中，构造函数的执行会按照定义时的继承顺序进行，与构造函数中定义顺序无关。原则: "),n("strong",[t._v("构造函数的执行顺序按照继承的顺序。")])]),t._v(" "),n("li",[t._v("如下是先执行 A，再执行 B"),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('contract E is A, B("EEEEEEEEEEEEE") {\n    constructor(string memory _name) A(_name) {}\n}\n')])])])]),t._v(" "),n("li",[t._v("如下是先执行 B，再执行 A"),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('contract E is B("EEEEEEEEEEEEE"),A {\n    constructor(string memory _name) A(_name) {}\n}\n')])])])])])]),t._v(" "),n("li",[t._v("子合约调用父合约的方法\n"),n("ol",[n("li",[t._v("直接使用合约名调用 "),n("code",[t._v("ParentContractName.functionName()")]),t._v(";")]),t._v(" "),n("li",[t._v("使用 super 关键字 "),n("code",[t._v("super.functionName()")]),t._v(" "),n("ul",[n("li",[t._v("super 会自动寻找父合约，并执行对应的方法；")]),t._v(" "),n("li",[n("strong",[t._v("如果是多个父级，那么父级都会执行。但有时候又不会，执行顺序的原理，这些需要详细的了解")])]),t._v(" "),n("li",[t._v("如果 super 导致 2 个父级同时触发同一个爷爷合约的相同方法；则爷爷的方法只执行一次。一个合约的同一个方法只会执行一次，不会执行多次。")])])]),t._v(" "),n("li",[t._v("执行顺序：像水中的冒泡一样，由下向上进行执行。但是如果多层级的执行，顺序规律还没有找到规律。")])])]),t._v(" "),n("li",[t._v("聊一聊合约继承\n"),n("ul",[n("li",[t._v("以上的内容精简回答")]),t._v(" "),n("li",[t._v("修饰符可以继承")]),t._v(" "),n("li",[t._v("事件不可以继承，但是可以重载")]),t._v(" "),n("li",[n("code",[t._v("fallback")]),t._v(" 可以继承，但是需要保持原有的 "),n("code",[t._v("payable/nonpayable")])]),t._v(" "),n("li",[n("code",[t._v("receive")]),t._v(" 可以继承，但是需要保持原有的 "),n("code",[t._v("payable/nonpayable")])])])])])])}),[],!1,null,null,null);n.default=a.exports}}]);