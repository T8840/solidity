(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{449:function(t,e,a){"use strict";a.r(e);var n=a(2),s=Object(n.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_16-assembly-内联汇编"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-assembly-内联汇编"}},[t._v("#")]),t._v(" 16.Assembly:内联汇编")]),t._v(" "),e("p",[t._v("使用内联汇编，可以在 Solidity 源程序中嵌入汇编代码，对 EVM 有更细粒度的控制。内联汇编主要用在编写库函数时很有用，一般用于写工具函数，比如椭圆签名解析等。在项目中用汇编编主要是 opensea 的 "),e("a",{attrs:{href:"https://github.com/ProjectOpenSea/seaport",target:"_blank",rel:"noopener noreferrer"}},[t._v("seaport"),e("OutboundLink")],1),t._v(" 合约.")]),t._v(" "),e("p",[t._v("在合约的内部使用汇编，是在合约内部包含 "),e("code",[t._v("assembly")]),t._v(" 关键字进行编写的，在 Solidity "),e("code",[t._v("inline assembly")]),t._v("(内联汇编) 中的语言被称为 Yul。"),e("a",{attrs:{href:"https://docs.soliditylang.org/zh/latest/yul.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Yul"),e("OutboundLink")],1),t._v(" 除了在 Solidity 之中作为 inline assembly 的一部分，也能当作独立的直译语言能够被编译成 bytecode 给不同的后端。")]),t._v(" "),e("p",[t._v("注意：内联汇编是一种在底层访问以太坊虚拟机的语言，由于编译器无法对汇编语句进行检查，所以 Solidity 提供的很多重要安全特性都没办法作用于汇编。写汇编代码相对比较困难，很多时候只有在处理一些相对复杂的问题时才需要使用它，并且开发者需要明确知道自己要做什么。")]),t._v(" "),e("h2",{attrs:{id:"_1️⃣-基本格式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1️⃣-基本格式"}},[t._v("#")]),t._v(" 1️⃣ 基本格式")]),t._v(" "),e("p",[t._v("通过 "),e("code",[t._v("assembly {}")]),t._v(" 包裹代码。并且内部每一行语句不需要使用"),e("code",[t._v(";")]),t._v("显示的标注结束。Assembly 也支持注释，可以使用 "),e("code",[t._v("//")]),t._v(" 和 "),e("code",[t._v("/* */")]),t._v(" 来进行注释。")]),t._v(" "),e("p",[t._v("⚠️ 注意： Inline Assembly 中，代码块之间是不能彼此沟通的，里面声明的变量都是本地变量。")]),t._v(" "),e("h3",{attrs:{id:"例子-不同代码块无法互相访问"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#例子-不同代码块无法互相访问"}},[t._v("#")]),t._v(" 例子: 不同代码块无法互相访问")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly() public view returns (uint256) {\n        assembly {\n            let x := 2\n        }\n        assembly {\n            let y := x // DeclarationError: Identifier "x" not found.\n        }\n    }\n}\n')])])]),e("p",[t._v("let 指令执行如下任务：")]),t._v(" "),e("ul",[e("li",[t._v("创建一个新的堆栈槽位")]),t._v(" "),e("li",[t._v("为变量保留该槽位")]),t._v(" "),e("li",[t._v("当到达代码块结束时自动销毁该槽位")])]),t._v(" "),e("p",[t._v("因此，使用 let 指令在汇编代码块中定义的变量，在代码块外部是无法访问的。但是内部代码块可以访问外部代码块的内容。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly() public pure {\n        assembly {\n            let x := 3\n\n            {\n                let y := x // success\n            } // 到此处会销毁y\n        }\n    }\n}\n")])])]),e("h3",{attrs:{id:"例子-简单的加法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#例子-简单的加法"}},[t._v("#")]),t._v(" 例子: 简单的加法")]),t._v(" "),e("p",[t._v("下面是一个计算 "),e("code",[t._v("_x + _y")]),t._v(" 的两种写法对比，汇编的语法节省了 "),e("code",[t._v("1.76%")]),t._v(" 的 gas。 assembly 核心是更细粒度的控制，省 gas 只是它的外在表现。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    // 输入 1,2 ; 输出 22307 gas\n    function addSolidity(uint256 _x, uint256 _y) public pure returns (uint256) {\n        return (_x + _y);\n    }\n\n    // 输入 1,2 ; 输出 21915 gas\n    function addAssembly(uint256 _x, uint256 _y) public pure returns (uint256) {\n        assembly {\n            // let result 是声明一个变量 result\n            // add(_x, _y) 是计算 x + y 的结果\n            // := 是将 x + y 的结果赋值给变量 result\n            let result := add(_x, _y)\n\n            // mstore(0x0, result) 在内存 `0x0` 的位置储存 `result`\n            mstore(0x0, result)\n\n            // 从内存索引 0x0 位置返回32字节\n            return(0x0, 32)\n        }\n    }\n}\n")])])]),e("h2",{attrs:{id:"_2️⃣-语言基础"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2️⃣-语言基础"}},[t._v("#")]),t._v(" 2️⃣ 语言基础")]),t._v(" "),e("p",[t._v("Yul 提供了高级结构，如 "),e("code",[t._v("for")]),t._v(" 循环、"),e("code",[t._v("if")]),t._v(" 语句 "),e("code",[t._v("switch")]),t._v(" 和函数调用等等，下面按照分类进行介绍。")]),t._v(" "),e("p",[t._v("在 Inline Assembly 中，以下几个点很重要：")]),t._v(" "),e("ul",[e("li",[t._v("赋值: 使用的是"),e("code",[t._v(":=")]),t._v("，而不是"),e("code",[t._v("=")]),t._v("。")]),t._v(" "),e("li",[t._v("声明变量: 使用 "),e("code",[t._v("let")]),t._v(" 声明；（不是正常带有指定类型的强类型方式）")])]),t._v(" "),e("h3",{attrs:{id:"声明与赋值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#声明与赋值"}},[t._v("#")]),t._v(" 声明与赋值")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly() public pure returns (uint256, uint256) {\n        assembly {\n            let x := 2  // 声明 x，赋值为2\n            let y       // 声明 y，初始化为 0\n            y := 5      // 赋值 y 为5\n\n            mstore(0x0, x) // 内存中储存 x\n            mstore(add(0x0, 32), y) // 内存中移动32位，再储存y\n\n            // 返回内存中 0 - 64 的数据\n            return(0x0, 64)\n        }\n    }\n}\n")])])]),e("p",[t._v("结果就是 "),e("code",[t._v("2,5")]),t._v("；")]),t._v(" "),e("p",[t._v("在 Solidity 汇编中字面量的写法与 Solidity 一致。但是 字符串字面量 最多可以包含 32 个字符。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly() public pure {\n        assembly {\n            let a := 0x123 // 16进制\n            let b := 42 // 10进制\n            let c := "hello world" // 字符串\n            let d := "very long string more than 32 bytes" // 长度 35 的 字符串，错误！\n        }\n    }\n}\n')])])]),e("h3",{attrs:{id:"汇编只能读取局部变量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#汇编只能读取局部变量"}},[t._v("#")]),t._v(" 汇编只能读取局部变量")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    uint256 a = 2;\n    function demoAssembly() public pure {\n        uint256 b = 5;\n        assembly {\n            // 可以读取 x 和 y\n            let x := add(2, 3)\n            let y := 10\n            let z := add(x, y)\n        }\n        assembly {\n            // 可以读取 x 和 b\n            let x := add(2, 3)\n            let y := mul(x, b)\n        }\n        assembly {\n            let x := add(2, 3)\n\n            // ❌ TypeError: Only local variables are supported.\n            // To access storage variables, use the ".slot" and ".offset" suffixes.\n            let y := mul(x, a)\n        }\n    }\n}\n')])])]),e("h2",{attrs:{id:"_3️⃣-条件判断"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3️⃣-条件判断"}},[t._v("#")]),t._v(" 3️⃣ 条件判断")]),t._v(" "),e("ul",[e("li",[t._v("if")]),t._v(" "),e("li",[t._v("switch")])]),t._v(" "),e("h3",{attrs:{id:"if"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#if"}},[t._v("#")]),t._v(" if")]),t._v(" "),e("p",[t._v("特点如下")]),t._v(" "),e("ul",[e("li",[t._v("只有 if ，没有 else")]),t._v(" "),e("li",[t._v("if 语句强制要求代码块使用大括号，"),e("code",[t._v("{}")]),t._v("不允许省略")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly() public pure {\n        uint256 x;\n        assembly {\n            // success\n            if iszero(x) {\n                x := sub(1, x)\n            }\n\n            // fail: 没有使用 {} 包裹代码\n            // if iszero(x) revert(0, 0)\n        }\n    }\n}\n")])])]),e("p",[t._v("如果需要在 Solidity 内联汇编中检查多种条件，可以考虑使用 switch 语句。")]),t._v(" "),e("h3",{attrs:{id:"switch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#switch"}},[t._v("#")]),t._v(" switch")]),t._v(" "),e("p",[t._v("switch 语句支持 一个默认分支 default，当表达式的值不匹配任何其他分支条件时，将 执行默认分支的代码。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly(uint256 x) public pure returns (uint256 result) {\n        assembly {\n            switch x\n            case 0 {\n                result := 0\n            }\n            case 1 {\n                result := 1\n            }\n            default {\n                result := mul(x, x)\n            }\n        }\n    }\n}\n")])])]),e("h2",{attrs:{id:"_4️⃣-for-循环"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4️⃣-for-循环"}},[t._v("#")]),t._v(" 4️⃣ for 循环")]),t._v(" "),e("p",[t._v("for 循环也包含 3 个元素")]),t._v(" "),e("ul",[e("li",[t._v("初始化：比如"),e("code",[t._v("let i := 0")])]),t._v(" "),e("li",[t._v("执行条件：比如"),e("code",[t._v("lt(i, n)")]),t._v(" ，必须是函数风格表达式")]),t._v(" "),e("li",[t._v("迭代后续步骤：比如"),e("code",[t._v("add(i, 1)")])])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly() public pure returns (uint256 result) {\n        uint256 leng = 10;\n\n        assembly {\n            for\n            { let i := 0 }\n            lt(i, leng)\n            { i := add(i, 1) }\n            {\n                result := add(result, i)\n            }\n\n            // 下面可以省略\n            mstore(0x0, result)\n            return(0x0, 32)\n        }\n    }\n}\n")])])]),e("p",[t._v("for 循环的"),e("strong",[t._v("初始化部分")]),t._v("和"),e("strong",[t._v("迭代后续步骤")]),t._v("可以留空 , 改写为下面的格式")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly() public pure returns (uint256 result) {\n        uint256 leng = 10;\n        assembly {\n            let i := 0 // 初始条件写在这\n            for {} lt(i, leng) {} {\n                // 核心部分\n                result := add(result, i)\n\n                // 迭代后续步骤写在这\n                i := add(i, 1)\n            }\n\n            // 可以省略\n            mstore(0x0, result)\n            return(0x0, 32)\n        }\n    }\n}\n")])])]),e("p",[t._v("备注: "),e("code",[t._v("continue")]),t._v(" or "),e("code",[t._v("break")]),t._v(" 语句只能在 "),e("code",[t._v("for")]),t._v(" 循环体内使用")]),t._v(" "),e("h2",{attrs:{id:"_5️⃣-函数的定义和使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5️⃣-函数的定义和使用"}},[t._v("#")]),t._v(" 5️⃣ 函数的定义和使用")]),t._v(" "),e("p",[t._v("函数的运行机制如下：")]),t._v(" "),e("ul",[e("li",[t._v("从堆栈提取参数")]),t._v(" "),e("li",[t._v("将结果压入堆栈")]),t._v(" "),e("li",[t._v("和 Solidity 函数不同，不需要指定汇编函数的可见性\n"),e("ul",[e("li",[t._v("例如 public 或 private， 因为汇编函数仅在定义所在的汇编代码块内有效。")])])])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly() public pure returns (uint256 free_memory_pointer) {\n        assembly {\n            // 函数定义\n            function allocate(length) -> pos {\n                pos := mload(0x40)\n                mstore(0x40, add(pos, length))\n            }\n\n            // 函数使用\n            free_memory_pointer := allocate(64)\n        }\n    }\n}\n")])])]),e("h2",{attrs:{id:"_6️⃣-evm-内置函数-内置操作码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6️⃣-evm-内置函数-内置操作码"}},[t._v("#")]),t._v(" 6️⃣ EVM 内置函数/内置操作码")]),t._v(" "),e("ul",[e("li",[t._v("算数操作\n"),e("ul",[e("li",[e("code",[t._v("add")]),t._v(": 加法")]),t._v(" "),e("li",[e("code",[t._v("mul")]),t._v(":")])])]),t._v(" "),e("li",[t._v("比较操作\n"),e("ul",[e("li",[e("code",[t._v("lt")])]),t._v(" "),e("li",[e("code",[t._v("gt")])])])]),t._v(" "),e("li",[t._v("位操作\n"),e("ul",[e("li",[e("code",[t._v("not")]),t._v(":")]),t._v(" "),e("li",[e("code",[t._v("and")]),t._v(":")])])]),t._v(" "),e("li",[t._v("密码学操作，目前仅包含 keccak256")]),t._v(" "),e("li",[t._v("环境操作，主要指与区块链相关的全局信息，例如 blockhash 或 coinbase 收款账号")]),t._v(" "),e("li",[t._v("存储、内存和栈操作")]),t._v(" "),e("li",[t._v("交易与合约调用操作")]),t._v(" "),e("li",[t._v("停机操作")]),t._v(" "),e("li",[t._v("日志操作")])]),t._v(" "),e("p",[t._v("下面是详细的列表说明，标记为"),e("code",[t._v("-")]),t._v("的操作不返回结果，其他所有操作码只返回一个值。")]),t._v(" "),e("p",[t._v("标有 F、H、B、C 、I 和 L 分别自出现的时间，对应的如下")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("F")]),t._v(": Frontier")]),t._v(" "),e("li",[e("code",[t._v("H")]),t._v(": Homestead")]),t._v(" "),e("li",[e("code",[t._v("B")]),t._v(": Byzantium")]),t._v(" "),e("li",[e("code",[t._v("C")]),t._v(": Constantinople")]),t._v(" "),e("li",[e("code",[t._v("I")]),t._v(": Istanbul")]),t._v(" "),e("li",[e("code",[t._v("L")]),t._v(": London")])]),t._v(" "),e("p",[t._v("常见的常量值是 "),e("code",[t._v("0x20")]),t._v(" / "),e("code",[t._v("0x40")]),t._v(" , 代表十进制的 32 和 64。")]),t._v(" "),e("h3",{attrs:{id:"数学计算"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数学计算"}},[t._v("#")]),t._v(" 数学计算")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("操作符号")]),t._v(" "),e("th",[t._v("返回值")]),t._v(" "),e("th",[t._v("版本")]),t._v(" "),e("th",[t._v("解释说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("add(x, y)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[e("code",[t._v("x + y")])])]),t._v(" "),e("tr",[e("td",[t._v("sub(x, y)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[e("code",[t._v("x - y")])])]),t._v(" "),e("tr",[e("td",[t._v("mul(x, y)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[e("code",[t._v("x * y")])])]),t._v(" "),e("tr",[e("td",[t._v("div(x, y)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[e("code",[t._v("x / y")]),t._v(" (如果 y 为 0，则结果为 0)")])]),t._v(" "),e("tr",[e("td",[t._v("mod(x, y)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[e("code",[t._v("x % y")]),t._v(" (如果 y 为 0，则结果为 0)")])]),t._v(" "),e("tr",[e("td",[t._v("exp(x, y)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[e("code",[t._v("x")]),t._v(" 的 "),e("code",[t._v("y")]),t._v(" 次方")])]),t._v(" "),e("tr",[e("td",[t._v("addmod(x, y, m)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[e("code",[t._v("(x + y) % m")]),t._v(" 任意精度算术，如果 m == 0 则为 0")])]),t._v(" "),e("tr",[e("td",[t._v("mulmod(x, y, m)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[e("code",[t._v("(x * y) % m")]),t._v(" 任意精度算术，如果 m == 0 则为 0")])]),t._v(" "),e("tr",[e("td",[t._v("sdiv(x, y)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[e("code",[t._v("x / y")]),t._v(", 以二进制补码作为符号 (如果 y 为 0，则结果为 0)")])]),t._v(" "),e("tr",[e("td",[t._v("smod(x, y)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[e("code",[t._v("x % y")]),t._v(", 以二进制补码作为符号 (如果 y 为 0，则结果为 0)")])])])]),t._v(" "),e("h4",{attrs:{id:"add-加法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#add-加法"}},[t._v("#")]),t._v(" add: 加法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function demoAssembly(uint256 _x, uint256 _y)\n    public\n    pure\n    returns (uint256)\n{\n    assembly {\n        let result := add(_x, _y)\n        mstore(0x0, result)\n        return(0x0, 32)\n    }\n}\n")])])]),e("p",[t._v("上面合约函数，传入参数:"),e("code",[t._v("1,2")]),t._v("，返回"),e("code",[t._v("3")]),t._v("。")]),t._v(" "),e("p",[t._v("这里需要返回"),e("code",[t._v("uint256")]),t._v("类型，assembly 内部返回是，从什么位置开发，返回多少个数据。需要返回两个数据。比如我把 uint256 改为 uint8，代码如下")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function demoAssembly(uint8 _x, uint8 _y)\n    public\n    pure\n    returns (uint8)\n{\n    assembly {\n        let result := add(_x, _y)\n        mstore(0x0, result)\n        return(0x0, 2)\n    }\n}\n")])])]),e("p",[t._v("相同的参数会报错: "),e("code",[t._v("error:Failed to decode output: Error: data out-of-bounds (length=2, offset=32, code=BUFFER_OVERRUN, version=abi/5.5.0)")])]),t._v(" "),e("h4",{attrs:{id:"sub-减法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sub-减法"}},[t._v("#")]),t._v(" sub: 减法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly(uint256 _x, uint256 _y)\n        public\n        pure\n        returns (uint256)\n    {\n        assembly {\n            let result := sub(_x, _y)\n            mstore(0x0, result)\n            return(0x0, 32)\n        }\n    }\n}\n")])])]),e("p",[t._v("传入参数:"),e("code",[t._v("2,1")]),t._v("，返回"),e("code",[t._v("1")]),t._v("。")]),t._v(" "),e("p",[t._v("注意：这时候如果传参 "),e("code",[t._v("1,2")]),t._v("，会溢出返回，得到的结果不会报错，反而是:"),e("code",[t._v("115792089237316195423570985008687907853269984665640564039457584007913129639935")]),t._v("，因为 assembly 绕过了 solidity 的安全检查。当我们使用 assembly 编码时候，安全问题需要自己控制，不要错误的认为 solidity 的默认机制会保护代码。")]),t._v(" "),e("h4",{attrs:{id:"mul-乘法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mul-乘法"}},[t._v("#")]),t._v(" mul: 乘法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly(uint256 _x, uint256 _y)\n        public\n        pure\n        returns (uint256)\n    {\n        assembly {\n            let result := mul(_x, _y)\n            mstore(0x0, result)\n            return(0x0, 32)\n        }\n    }\n}\n")])])]),e("p",[t._v("传入参数:"),e("code",[t._v("2,3")]),t._v("，返回"),e("code",[t._v("6")]),t._v("。")]),t._v(" "),e("h4",{attrs:{id:"div-除法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#div-除法"}},[t._v("#")]),t._v(" div: 除法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly(uint256 _x, uint256 _y)\n        public\n        pure\n        returns (uint256)\n    {\n        assembly {\n            let result := div(_x, _y)\n            mstore(0x0, result)\n            return(0x0, 32)\n        }\n    }\n}\n")])])]),e("ul",[e("li",[t._v("传入参数:"),e("code",[t._v("3,2")]),t._v("，返回"),e("code",[t._v("1")]),t._v("。")]),t._v(" "),e("li",[t._v("传入参数:"),e("code",[t._v("3,1")]),t._v("，返回"),e("code",[t._v("3")]),t._v("。")]),t._v(" "),e("li",[t._v("传入参数:"),e("code",[t._v("3,0")]),t._v("，返回"),e("code",[t._v("0")]),t._v("。")])]),t._v(" "),e("h4",{attrs:{id:"mod-求模"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mod-求模"}},[t._v("#")]),t._v(" mod: 求模")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly(uint256 _x, uint256 _y)\n        public\n        pure\n        returns (uint256)\n    {\n        assembly {\n            let result := mod(_x, _y)\n            mstore(0x0, result)\n            return(0x0, 32)\n        }\n    }\n}\n")])])]),e("ul",[e("li",[t._v("传入参数:"),e("code",[t._v("3,2")]),t._v("，返回"),e("code",[t._v("1")])]),t._v(" "),e("li",[t._v("传入参数:"),e("code",[t._v("3,1")]),t._v("，返回"),e("code",[t._v("0")])]),t._v(" "),e("li",[t._v("传入参数:"),e("code",[t._v("3,0")]),t._v(",返回"),e("code",[t._v("0")])]),t._v(" "),e("li",[t._v("传入参数:"),e("code",[t._v("3,30")]),t._v(",返回"),e("code",[t._v("3")])])]),t._v(" "),e("h4",{attrs:{id:"exp-次方"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#exp-次方"}},[t._v("#")]),t._v(" exp: 次方")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly(uint256 _x, uint256 _y)\n        public\n        pure\n        returns (uint256)\n    {\n        assembly {\n            let result := exp(_x, _y)\n            mstore(0x0, result)\n            return(0x0, 32)\n        }\n    }\n}\n")])])]),e("ul",[e("li",[t._v("传入参数:"),e("code",[t._v("10,2")]),t._v("，返回"),e("code",[t._v("100")]),t._v("。")]),t._v(" "),e("li",[t._v("传入参数:"),e("code",[t._v("10,3")]),t._v("，返回"),e("code",[t._v("1000")]),t._v("。")])]),t._v(" "),e("h4",{attrs:{id:"addmod-先求和再求模"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#addmod-先求和再求模"}},[t._v("#")]),t._v(" addmod: 先求和再求模")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly(\n        uint256 _x,\n        uint256 _y,\n        uint256 _m\n    ) public pure returns (uint256) {\n        assembly {\n            let result := addmod(_x, _y, _m)\n            mstore(0x0, result)\n            return(0x0, 32)\n        }\n    }\n}\n")])])]),e("ul",[e("li",[t._v("传入参数:"),e("code",[t._v("2,3,3")]),t._v("，返回"),e("code",[t._v("2")]),t._v("。")])]),t._v(" "),e("h4",{attrs:{id:"mulmod-先相乘再求模"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mulmod-先相乘再求模"}},[t._v("#")]),t._v(" mulmod: 先相乘再求模")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly(\n        uint256 _x,\n        uint256 _y,\n        uint256 _m\n    ) public pure returns (uint256) {\n        assembly {\n            let result := mulmod(_x, _y, _m)\n            mstore(0x0, result)\n            return(0x0, 32)\n        }\n    }\n}\n\n")])])]),e("ul",[e("li",[t._v("传入参数:"),e("code",[t._v("2,3,3")]),t._v("，返回"),e("code",[t._v("0")]),t._v("。")])]),t._v(" "),e("h4",{attrs:{id:"二进制补码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二进制补码"}},[t._v("#")]),t._v(" 二进制补码")]),t._v(" "),e("p",[t._v("下面两个方法，用法基本和 div / mod 差不多")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("let result := sdiv(_x, _y)\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("let result := smod(_x, _y)\n")])])]),e("h3",{attrs:{id:"比较关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#比较关系"}},[t._v("#")]),t._v(" 比较关系")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("操作符号")]),t._v(" "),e("th",[t._v("返回值")]),t._v(" "),e("th",[t._v("版本")]),t._v(" "),e("th",[t._v("解释说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("gt(x, y)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("如果 "),e("code",[t._v("x > y")]),t._v(" 等于 1, 否则 0")])]),t._v(" "),e("tr",[e("td",[t._v("lt(x, y)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("如果 "),e("code",[t._v("x < y")]),t._v(" 等于 1, 否则 0")])]),t._v(" "),e("tr",[e("td",[t._v("eq(x, y)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("如果 "),e("code",[t._v("x == y")]),t._v(" 等于 1, 否则 0")])]),t._v(" "),e("tr",[e("td",[t._v("iszero(x)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("如果 "),e("code",[t._v("x == 0")]),t._v(" 等于 1, 否则 0")])]),t._v(" "),e("tr",[e("td",[t._v("slt(x, y)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("如果 "),e("code",[t._v("x < y")]),t._v(" 等于 1, 否则 0, 以二进制补码作为符号")])]),t._v(" "),e("tr",[e("td",[t._v("sgt(x, y)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("如果 "),e("code",[t._v("x > y")]),t._v(" 等于 1, 否则 0, 以二进制补码作为符号")])])])]),t._v(" "),e("h4",{attrs:{id:"gt-大于"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#gt-大于"}},[t._v("#")]),t._v(" gt: 大于")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly(uint256 _x, uint256 _y)\n        public\n        pure\n        returns (bool result)\n    {\n        assembly {\n            result := gt(_x, _y)\n        }\n    }\n}\n")])])]),e("ul",[e("li",[t._v("传入参数:"),e("code",[t._v("1,2")]),t._v("，返回 "),e("code",[t._v("false")])]),t._v(" "),e("li",[t._v("传入参数:"),e("code",[t._v("10,3")]),t._v("，返回 "),e("code",[t._v("true")])])]),t._v(" "),e("h4",{attrs:{id:"lt-小于"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#lt-小于"}},[t._v("#")]),t._v(" lt: 小于")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly(uint256 _x, uint256 _y)\n        public\n        pure\n        returns (bool result)\n    {\n        assembly {\n            result := lt(_x, _y)\n        }\n    }\n}\n")])])]),e("ul",[e("li",[t._v("传入参数:"),e("code",[t._v("1,2")]),t._v("，返回 "),e("code",[t._v("true")])]),t._v(" "),e("li",[t._v("传入参数:"),e("code",[t._v("10,3")]),t._v("，返回 "),e("code",[t._v("false")])])]),t._v(" "),e("h4",{attrs:{id:"eq-等于"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#eq-等于"}},[t._v("#")]),t._v(" eq: 等于")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly(uint256 _x, uint256 _y)\n        public\n        pure\n        returns (bool result)\n    {\n        assembly {\n            result := eq(_x, _y)\n        }\n    }\n}\n")])])]),e("ul",[e("li",[t._v("传入参数:"),e("code",[t._v("1,2")]),t._v("，返回 "),e("code",[t._v("false")])]),t._v(" "),e("li",[t._v("传入参数:"),e("code",[t._v("2,2")]),t._v("，返回 "),e("code",[t._v("true")])])]),t._v(" "),e("h4",{attrs:{id:"iszero-等于零"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#iszero-等于零"}},[t._v("#")]),t._v(" iszero: 等于零")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly(uint256 _x)\n        public\n        pure\n        returns (bool result)\n    {\n        assembly {\n            result := iszero(_x)\n        }\n    }\n}\n")])])]),e("p",[t._v("注意该参数只接收一个参数")]),t._v(" "),e("ul",[e("li",[t._v("传入参数:"),e("code",[t._v("1")]),t._v("，返回 "),e("code",[t._v("false")])]),t._v(" "),e("li",[t._v("传入参数:"),e("code",[t._v("0")]),t._v("，返回 "),e("code",[t._v("true")])])]),t._v(" "),e("h3",{attrs:{id:"按位-移位"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#按位-移位"}},[t._v("#")]),t._v(" 按位 & 移位")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("操作符号")]),t._v(" "),e("th",[t._v("返回值")]),t._v(" "),e("th",[t._v("版本")]),t._v(" "),e("th",[t._v("解释说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("not(x)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("对 x 按位取反,类似"),e("code",[t._v("~x")]),t._v(";"),e("code",[t._v("x")]),t._v(" 的按位非")])]),t._v(" "),e("tr",[e("td",[t._v("and(x, y)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("x 和 y 的按位与")])]),t._v(" "),e("tr",[e("td",[t._v("or(x, y)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("x 和 y 的按位或")])]),t._v(" "),e("tr",[e("td",[t._v("xor(x, y)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("x 和 y 的按位异或")])]),t._v(" "),e("tr",[e("td",[t._v("shl(x, y)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("C")]),t._v(" "),e("td",[t._v("y 逻辑左移 x 位")])]),t._v(" "),e("tr",[e("td",[t._v("shr(x, y)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("C")]),t._v(" "),e("td",[t._v("y 逻辑右移 x 位")])]),t._v(" "),e("tr",[e("td",[t._v("sar(x, y)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("C")]),t._v(" "),e("td",[t._v("将 y 算术右移 x 位")])])])]),t._v(" "),e("h4",{attrs:{id:"not-按位非"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#not-按位非"}},[t._v("#")]),t._v(" not: 按位非")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly(int256 _x) public pure returns (int256 result) {\n        assembly {\n            result := not(_x)\n        }\n    }\n}\n")])])]),e("ul",[e("li",[t._v("传入参数:"),e("code",[t._v("0")]),t._v("，返回 "),e("code",[t._v("-1")])]),t._v(" "),e("li",[t._v("传入参数:"),e("code",[t._v("1")]),t._v("，返回 "),e("code",[t._v("-2")])]),t._v(" "),e("li",[t._v("传入参数:"),e("code",[t._v("-1")]),t._v("，返回 "),e("code",[t._v("0")])]),t._v(" "),e("li",[t._v("传入参数:"),e("code",[t._v("-11")]),t._v("，返回 "),e("code",[t._v("10")])])]),t._v(" "),e("h4",{attrs:{id:"and-按位与"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#and-按位与"}},[t._v("#")]),t._v(" and: 按位与")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly() public pure returns (int256 result) {\n        int256 _x = 2;\n        int256 _y = 3;\n        assembly {\n            result := and(_x, _y)\n        }\n    }\n}\n")])])]),e("p",[t._v("结果是 2")]),t._v(" "),e("h4",{attrs:{id:"or-按位或"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#or-按位或"}},[t._v("#")]),t._v(" or: 按位或")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly() public pure returns (int256 result) {\n        int256 _x = 2;\n        int256 _y = 3;\n        assembly {\n            result := or(_x, _y)\n        }\n    }\n}\n")])])]),e("p",[t._v("结果是 3")]),t._v(" "),e("h4",{attrs:{id:"xor-按位异或"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#xor-按位异或"}},[t._v("#")]),t._v(" xor: 按位异或")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly() public pure returns (int256 result) {\n        int256 _x = 2;\n        int256 _y = 3;\n        assembly {\n            result := xor(_x, _y)\n        }\n    }\n}\n")])])]),e("p",[t._v("结果 1")]),t._v(" "),e("h4",{attrs:{id:"shl-逻辑左移"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#shl-逻辑左移"}},[t._v("#")]),t._v(" shl: 逻辑左移")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly() public pure returns (uint256 result) {\n        uint256 A = 2;\n        assembly {\n            result := shl(A, 1) // 4\n        }\n    }\n}\n")])])]),e("h4",{attrs:{id:"shr-逻辑右移"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#shr-逻辑右移"}},[t._v("#")]),t._v(" shr: 逻辑右移")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly() public pure returns (uint256 result) {\n        uint256 A = 2;\n        assembly {\n            result := shr(A, 1) // 0\n        }\n    }\n}\n")])])]),e("h4",{attrs:{id:"sar-算术右移"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sar-算术右移"}},[t._v("#")]),t._v(" sar: 算术右移")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly() public pure returns (uint256 result) {\n        uint256 A = 2;\n        assembly {\n            result := sar(A, 1) // 0\n        }\n    }\n}\n")])])]),e("h3",{attrs:{id:"evm-区块交易相关"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#evm-区块交易相关"}},[t._v("#")]),t._v(" EVM 区块交易相关")]),t._v(" "),e("table",{staticClass:"docutils",attrs:{border:"1"}},[e("thead",[e("tr",[e("th",[t._v("操作符号")]),t._v(" "),e("th",[t._v("返回值")]),t._v(" "),e("th",[t._v("版本")]),t._v(" "),e("th",[t._v("解释说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("address()")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("当前合约地址 / execution context")])]),t._v(" "),e("tr",[e("td",[t._v("balance(a)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("地址 a 的 wei 余额")])]),t._v(" "),e("tr",[e("td",[t._v("selfbalance()")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("I")]),t._v(" "),e("td",[t._v("相当于 "),e("code",[t._v("balance(address())")]),t._v("，但更便宜")])]),t._v(" "),e("tr",[e("td",[t._v("extcodehash(a)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("C")]),t._v(" "),e("td",[t._v("地址 a 的代码哈希")])]),t._v(" "),e("tr",[e("td",{attrs:{colspan:"4"}},[e("center",[e("strong",[t._v("msg 相关")])])],1)]),t._v(" "),e("tr",[e("td",[t._v("caller()")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("call sender ( 类似"),e("code",[t._v("msg.sender")]),t._v("？) (excluding "),e("code",[t._v("delegatecall")]),t._v(")")])]),t._v(" "),e("tr",[e("td",[t._v("callvalue()")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("wei sent together with the current call（类似"),e("code",[t._v("msg.value")]),t._v("？）")])]),t._v(" "),e("tr",[e("td",{attrs:{colspan:"4"}},[e("center",[e("strong",[t._v("block 相关")])])],1)]),t._v(" "),e("tr",[e("td",[t._v("chainid()")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("I")]),t._v(" "),e("td",[t._v("当前网络的链 ID (EIP-1344)")])]),t._v(" "),e("tr",[e("td",[t._v("basefee()")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("L")]),t._v(" "),e("td",[t._v("当前区块的基本费用 (EIP-3198 and EIP-1559)")])]),t._v(" "),e("tr",[e("td",[t._v("timestamp()")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("当前块的时间戳，自纪元以来的秒数")])]),t._v(" "),e("tr",[e("td",[t._v("coinbase()")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("当前采矿受益人")])]),t._v(" "),e("tr",[e("td",[t._v("number()")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("当前区块号")])]),t._v(" "),e("tr",[e("td",[t._v("difficulty()")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("当前区块的难度")])]),t._v(" "),e("tr",[e("td",[t._v("gaslimit()")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("当前区块的区块 gas limit")])]),t._v(" "),e("tr",[e("td",{attrs:{colspan:"4"}},[e("center",[e("strong",[t._v("tx 相关")])])],1)]),t._v(" "),e("tr",[e("td",[t._v("origin()")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("交易发送方")])]),t._v(" "),e("tr",[e("td",[t._v("gasprice()")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("交易的 gas 价格")])]),t._v(" "),e("tr",[e("td",{attrs:{colspan:"4"}},[e("center",[e("strong",[t._v("其它")])])],1)]),t._v(" "),e("tr",[e("td",[t._v("gas()")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("剩余 gas")])]),t._v(" "),e("tr",[e("td",[t._v("blockhash(b)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("指定 block 的 hash - 仅适用于最后 256 个块，不包括当前块")])])])]),t._v(" "),e("h4",{attrs:{id:"address"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#address"}},[t._v("#")]),t._v(" address()")]),t._v(" "),e("p",[t._v("相当于 "),e("code",[t._v("address(this)")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly() public view returns (address ads1, address ads2) {\n        assembly {\n            ads1 := address()\n        }\n\n        ads2 = address(this);\n    }\n}\n")])])]),e("p",[t._v("返回")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("0:address: ads1 0x3c725134d74D5c45B4E4ABd2e5e2a109b5541288")])]),t._v(" "),e("li",[e("code",[t._v("1:address: ads2 0x3c725134d74D5c45B4E4ABd2e5e2a109b5541288")])])]),t._v(" "),e("h4",{attrs:{id:"balance-a"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#balance-a"}},[t._v("#")]),t._v(" balance(a)")]),t._v(" "),e("p",[t._v("相当于 "),e("code",[t._v("address.balance")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly()\n        public\n        view\n        returns (uint256 result1, uint256 result2)\n    {\n        address sender = msg.sender;\n        assembly {\n            result1 := balance(sender)\n        }\n\n        result2 = address(sender).balance;\n    }\n}\n")])])]),e("p",[t._v("返回")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("0:uint256: result1 99999999999992173039")])]),t._v(" "),e("li",[e("code",[t._v("1:uint256: result2 99999999999992173039")])])]),t._v(" "),e("h4",{attrs:{id:"selfbalance"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#selfbalance"}},[t._v("#")]),t._v(" selfbalance()")]),t._v(" "),e("p",[t._v("相当于 "),e("code",[t._v("balance(address())")]),t._v("，但更便宜")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    constructor() payable {}\n\n    function demoAssembly()\n        public\n        view\n        returns (uint256 result1, uint256 result2)\n    {\n        assembly {\n            result1 := balance(address())\n        }\n\n        result2 = address(this).balance;\n    }\n}\n")])])]),e("h4",{attrs:{id:"extcodehash-a"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#extcodehash-a"}},[t._v("#")]),t._v(" extcodehash(a)")]),t._v(" "),e("p",[t._v("相当于 "),e("code",[t._v("address.codehash")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly()\n        public\n        view\n        returns (bytes32 result1, bytes32 result2)\n    {\n        address sender = msg.sender;\n        assembly {\n            result1 := extcodehash(address())\n        }\n        result2 = address(this).codehash;\n    }\n}\n")])])]),e("ul",[e("li",[e("code",[t._v("0:bytes32: result1 0xcbefd958c5e7814e7e635b599c5859eb893c410292a7f9f82088c3e84ee3c0e9")])]),t._v(" "),e("li",[e("code",[t._v("1:bytes32: result2 0xcbefd958c5e7814e7e635b599c5859eb893c410292a7f9f82088c3e84ee3c0e9")])])]),t._v(" "),e("h4",{attrs:{id:"caller"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#caller"}},[t._v("#")]),t._v(" caller()")]),t._v(" "),e("p",[t._v("相当于 "),e("code",[t._v("msg.sender")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly() public view returns (address ads1, address ads2) {\n        assembly {\n            ads1 := caller()\n        }\n\n        ads2 = msg.sender;\n    }\n}\n")])])]),e("h4",{attrs:{id:"callvalue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#callvalue"}},[t._v("#")]),t._v(" callvalue()")]),t._v(" "),e("p",[t._v("相当于 "),e("code",[t._v("msg.value")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly()\n        public\n        payable\n        returns (uint256 result1, uint256 result2)\n    {\n        assembly {\n            result1 := callvalue()\n        }\n        result2 = msg.value;\n    }\n}\n")])])]),e("h4",{attrs:{id:"chainid"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#chainid"}},[t._v("#")]),t._v(" chainid()")]),t._v(" "),e("p",[t._v("相当于 "),e("code",[t._v("block.chainid")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly()\n        public\n        view\n        returns (uint256 result1, uint256 result2)\n    {\n        assembly {\n            result1 := chainid() // 1\n        }\n        result2 = block.chainid; // 1\n    }\n}\n")])])]),e("h4",{attrs:{id:"basefee"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#basefee"}},[t._v("#")]),t._v(" basefee()")]),t._v(" "),e("p",[t._v("相当于 "),e("code",[t._v("block.basefee")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly()\n        public\n        view\n        returns (uint256 result1, uint256 result2)\n    {\n        assembly {\n            result1 := basefee()\n        }\n        result2 = block.basefee;\n    }\n}\n")])])]),e("h4",{attrs:{id:"timestamp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#timestamp"}},[t._v("#")]),t._v(" timestamp()")]),t._v(" "),e("p",[t._v("相当于 "),e("code",[t._v("block.timestamp")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly()\n        public\n        view\n        returns (uint256 result1, uint256 result2)\n    {\n        assembly {\n            result1 := timestamp()\n        }\n        result2 = block.timestamp;\n    }\n}\n")])])]),e("h4",{attrs:{id:"coinbase"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#coinbase"}},[t._v("#")]),t._v(" coinbase()")]),t._v(" "),e("p",[t._v("相当于 "),e("code",[t._v("block.coinbase")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly()\n        public\n        view\n        returns (address result1, address result2)\n    {\n        assembly {\n            result1 := coinbase()\n        }\n        result2 = block.coinbase;\n    }\n}\n")])])]),e("h4",{attrs:{id:"number"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#number"}},[t._v("#")]),t._v(" number()")]),t._v(" "),e("p",[t._v("相当于 "),e("code",[t._v("block.number")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly()\n        public\n        view\n        returns (uint256 result1, uint256 result2)\n    {\n        assembly {\n            result1 := number()\n        }\n        result2 = block.number;\n    }\n}\n")])])]),e("h4",{attrs:{id:"difficulty"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#difficulty"}},[t._v("#")]),t._v(" difficulty()")]),t._v(" "),e("p",[t._v("相当于 "),e("code",[t._v("block.difficulty")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly()\n        public\n        view\n        returns (uint256 result1, uint256 result2)\n    {\n        assembly {\n            result1 := difficulty()\n        }\n        result2 = block.difficulty;\n    }\n}\n")])])]),e("h4",{attrs:{id:"gaslimit"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#gaslimit"}},[t._v("#")]),t._v(" gaslimit()")]),t._v(" "),e("p",[t._v("相当于 "),e("code",[t._v("block.gaslimit")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly()\n        public\n        view\n        returns (uint256 result1, uint256 result2)\n    {\n        assembly {\n            result1 := gaslimit()\n        }\n        result2 = block.gaslimit;\n    }\n}\n")])])]),e("h4",{attrs:{id:"origin"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#origin"}},[t._v("#")]),t._v(" origin()")]),t._v(" "),e("p",[t._v("相当于 "),e("code",[t._v("tx.origin")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly()\n        public\n        view\n        returns (address result1, address result2)\n    {\n        assembly {\n            result1 := origin()\n        }\n        result2 = tx.origin;\n    }\n}\n")])])]),e("h4",{attrs:{id:"gasprice"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#gasprice"}},[t._v("#")]),t._v(" gasprice()")]),t._v(" "),e("p",[t._v("相当于 "),e("code",[t._v("tx.gasprice")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly()\n        public\n        view\n        returns (uint256 result1, uint256 result2)\n    {\n        assembly {\n            result1 := gasprice()\n        }\n        result2 = tx.gasprice;\n    }\n}\n")])])]),e("h4",{attrs:{id:"gas"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#gas"}},[t._v("#")]),t._v(" gas()")]),t._v(" "),e("p",[t._v("相当于 "),e("code",[t._v("gasleft()")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly()\n        public\n        view\n        returns (uint256 result1, uint256 result2)\n    {\n        assembly {\n            result1 := gas() // 2978815\n        }\n\n        // 与 assembly 之间的顺序不改变最后的值\n        // 所以 assembly 优先执行？\n        result2 = gasleft(); // 2978808\n    }\n}\n")])])]),e("h4",{attrs:{id:"blockhash-b"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#blockhash-b"}},[t._v("#")]),t._v(" blockhash(b)")]),t._v(" "),e("p",[t._v("相当于 "),e("code",[t._v("blockhash(number)")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function demoAssembly()\n        public\n        view\n        returns (bytes32 result1, bytes32 result2)\n    {\n        assembly {\n            result1 := blockhash(1)\n        }\n        result2 = blockhash(1);\n    }\n}\n")])])]),e("h3",{attrs:{id:"常见方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见方法"}},[t._v("#")]),t._v(" 常见方法")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("操作符号")]),t._v(" "),e("th",[t._v("返回值")]),t._v(" "),e("th",[t._v("版本")]),t._v(" "),e("th",[t._v("解释说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("sload(p)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[e("code",[t._v("storage[p]")])])]),t._v(" "),e("tr",[e("td",[t._v("mload(p)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[e("code",[t._v("mem[p…(p+32))")])])]),t._v(" "),e("tr",[e("td",[t._v("sstore(p, v)")]),t._v(" "),e("td",[t._v("-")]),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[e("code",[t._v("storage[p] := v")])])]),t._v(" "),e("tr",[e("td",[t._v("mstore(p, v)")]),t._v(" "),e("td",[t._v("-")]),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[e("code",[t._v("mem[p…(p+32)) := v")])])]),t._v(" "),e("tr",[e("td",[t._v("mstore8(p, v)")]),t._v(" "),e("td",[t._v("-")]),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[e("code",[t._v("mem[p] := v")]),t._v(" & 0xff (只修改单个字节)")])]),t._v(" "),e("tr",[e("td",[t._v("keccak256(p, n)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[e("code",[t._v("keccak(mem[p…(p+n)))")])])]),t._v(" "),e("tr",[e("td",[t._v("create(v, p, n)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("create 创建合约")])]),t._v(" "),e("tr",[e("td",[t._v("create2(v, p, n, s)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("C")]),t._v(" "),e("td",[t._v("create2 创建合约")])])])]),t._v(" "),e("p",[t._v("小例子:")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("mload(p)")]),t._v(": 分配数据")]),t._v(" "),e("li",[e("code",[t._v("mstore(offset, value)")]),t._v(": 在 "),e("code",[t._v("offset")]),t._v(" 的位置储存 "),e("code",[t._v("value")])])]),t._v(" "),e("h4",{attrs:{id:"sload-p"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sload-p"}},[t._v("#")]),t._v(" sload(p)")]),t._v(" "),e("p",[t._v("sload 是 storage load，"),e("code",[t._v("sload(key)")]),t._v(" 是从 storage 的哪个 slot 来 load，详细原理可以在后面介绍的 "),e("strong",[t._v("状态变量在存储中的布局")]),t._v(" 了解更多。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    uint256 public a = 123;\n    uint256 public b = 456;\n\n    function demoAssembly() public view returns (uint256) {\n        assembly {\n            // v 是长度是 32 bytes\n            // 从 slot #0 读数据 => 读到的是 123\n            // 从 slot #1 读数据 => 读到的是 456\n            let v := sload(0)\n\n            // 在内存位置 0x80 处储存变量 v 后面的数据\n            mstore(0x80, v)\n\n            // 返回值:从 0x80 位置，返回 32个字节\n            return(0x80, 32)\n        }\n    }\n}\n")])])]),e("p",[t._v("上面例子中，"),e("code",[t._v("slot #0")]),t._v(" 是 123，"),e("code",[t._v("slot #1")]),t._v(" 是 456。")]),t._v(" "),e("p",[t._v("注意: "),e("code",[t._v("slot #0")]),t._v(" 可能是多个状态变量公用的。比如把状态变量改为如下类型,读 "),e("code",[t._v("slot #0")]),t._v(" ，该位置储存了"),e("code",[t._v("a+b")]),t._v(";")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("uint128 public a = 1;\nuint128 public b = 2;\nuint256 public c = 456;\n")])])]),e("h4",{attrs:{id:"mload-p"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mload-p"}},[t._v("#")]),t._v(" mload(p)")]),t._v(" "),e("p",[t._v("mload 是 memory load，"),e("code",[t._v("mload(key)")]),t._v(" 是从 memory 的哪个 slot 来 load，类似 "),e("code",[t._v("sload")]),t._v("。")]),t._v(" "),e("ul",[e("li",[t._v("问题：内存数据 mload 时为什么从第 32 位开始?\n"),e("ul",[e("li",[t._v("答案：前 32 个字节存储的是数据的长度;")]),t._v(" "),e("li",[t._v("参考: https://www.cnblogs.com/wanghui-garcia/p/9592807.html")])])])]),t._v(" "),e("h4",{attrs:{id:"sstore-p-v"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sstore-p-v"}},[t._v("#")]),t._v(" sstore(p, v)")]),t._v(" "),e("h4",{attrs:{id:"mstore-p-v"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mstore-p-v"}},[t._v("#")]),t._v(" mstore(p, v)")]),t._v(" "),e("p",[t._v('下面 name1 和 name2 都返回 "Anbang" 的字符串')]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    // gas 23471\n    bytes6 public name1 = "Anbang"; // 0x416e62616e67\n\n    // gas 21229\n    function name2() public pure returns (string memory) {\n        assembly {\n            // 在 0x20 处 储存值 0x20\n            mstore(0x20, 0x20)\n\n            // name1 length = 0x06\n            // 参数1: 0x40 + length = 0x40 + 0x06 => 0x46\n            // 参数2: length + name1  = 0x46 + 0x416e62616e67 => 0x06416e62616e67\n            mstore(0x46, 0x06416e62616e67)\n\n            // 返回 memory 从 0x20处之后的 0x60 长度的数据\n            return(0x20, 0x60)\n        }\n    }\n}\n')])])]),e("p",[t._v("上面是从"),e("code",[t._v("0x20")]),t._v("处开始写数据，这个位置不是强制的，使用"),e("code",[t._v("0x00")]),t._v("也可以的。")]),t._v(" "),e("h4",{attrs:{id:"mstore8-p-v"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mstore8-p-v"}},[t._v("#")]),t._v(" mstore8(p, v)")]),t._v(" "),e("h4",{attrs:{id:"keccak256-p-n"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#keccak256-p-n"}},[t._v("#")]),t._v(" keccak256(p, n)")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    // 0x01\n    function solidityKeccak(bytes memory _input) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_input));\n    }\n\n    // 0x01\n    function assemblyKeccak(bytes memory _input)\n        public\n        pure\n        returns (bytes32 x)\n    {\n        assembly {\n            x := keccak256(add(_input, 0x20), mload(_input))\n        }\n    }\n}\n")])])]),e("h4",{attrs:{id:"create-v-p-n"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#create-v-p-n"}},[t._v("#")]),t._v(" create(v, p, n)")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v(" assembly {\n    // create(v,p,n);\n    // v 是 发送的ETH值\n    // p 是 内存中机器码开始的位置\n    // n 是 内存中机器码的大小\n    // msg.value 不能使用，需要用 callvalue()\n    adds := create(callvalue(), add(_code, 0x20), mload(_code))\n}\n")])])]),e("h4",{attrs:{id:"create2-v-p-n-s"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#create2-v-p-n-s"}},[t._v("#")]),t._v(" create2(v, p, n, s)")]),t._v(" "),e("p",[t._v("下面是 "),e("a",{attrs:{href:"https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Factory.sol",target:"_blank",rel:"noopener noreferrer"}},[t._v("UniswapV2Factory"),e("OutboundLink")],1),t._v(" 中创建 pair 核心逻辑")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Z {\n    bytes6 public name1 = "Anbang";\n}\n\ncontract Demo {\n    function addr() public returns (address pair) {\n        bytes memory bytecode = type(Z).creationCode;\n        // bytes32 salt = keccak256(abi.encodePacked(address(0), address(1)));\n        uint256 salt = block.number;\n        assembly {\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n    }\n}\n')])])]),e("h3",{attrs:{id:"操作数据-大小"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#操作数据-大小"}},[t._v("#")]),t._v(" 操作数据/大小")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("操作符号")]),t._v(" "),e("th",[t._v("返回值")]),t._v(" "),e("th",[t._v("版本")]),t._v(" "),e("th",[t._v("解释说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("msize()")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("内存大小，即最大访问内存索引")])]),t._v(" "),e("tr",[e("td",[t._v("pc()")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("当前在代码中的位置")])]),t._v(" "),e("tr",[e("td",[t._v("codesize()")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("当前合约的代码大小 / execution context")])]),t._v(" "),e("tr",[e("td",[t._v("codecopy(t, f, s)")]),t._v(" "),e("td",[t._v("-")]),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("从位置 f 的代码复制 s 个字节到位置 t 的内存")])]),t._v(" "),e("tr",[e("td",[t._v("extcodesize(a)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("获取地址 a 的代码大小")])]),t._v(" "),e("tr",[e("td",[t._v("extcodecopy(a, t, f, s)")]),t._v(" "),e("td",[t._v("-")]),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("像 codecopy(t, f, s) 但在地址 a 处获取代码")])]),t._v(" "),e("tr",[e("td",[t._v("signextend(i, x)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("sign extend from "),e("code",[t._v("(i*8+7)")]),t._v("th bit counting from least significant")])]),t._v(" "),e("tr",[e("td",[t._v("byte(n, x)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("x 的第 n 个字节，这个索引是从 0 开始的")])]),t._v(" "),e("tr",[e("td",[t._v("pop(x)")]),t._v(" "),e("td",[t._v("-")]),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("丢弃值 x")])])])]),t._v(" "),e("h4",{attrs:{id:"msize"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#msize"}},[t._v("#")]),t._v(" msize()")]),t._v(" "),e("p",[t._v("内存大小，即最大访问内存索引")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    function test() public pure returns (int256) {\n        int8 v0 = 1;\n        assembly {\n            v0 := msize()\n        }\n        return int256(v0);\n    }\n}\n")])])]),e("h4",{attrs:{id:"pc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pc"}},[t._v("#")]),t._v(" pc()")]),t._v(" "),e("h4",{attrs:{id:"codesize"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#codesize"}},[t._v("#")]),t._v(" codesize()")]),t._v(" "),e("h4",{attrs:{id:"codecopy-t-f-s"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#codecopy-t-f-s"}},[t._v("#")]),t._v(" codecopy(t, f, s)")]),t._v(" "),e("h4",{attrs:{id:"extcodesize-a"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#extcodesize-a"}},[t._v("#")]),t._v(" extcodesize(a)")]),t._v(" "),e("h4",{attrs:{id:"extcodecopy-a-t-f-s"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#extcodecopy-a-t-f-s"}},[t._v("#")]),t._v(" extcodecopy(a, t, f, s)")]),t._v(" "),e("h4",{attrs:{id:"signextend-i-x"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#signextend-i-x"}},[t._v("#")]),t._v(" signextend(i, x)")]),t._v(" "),e("h4",{attrs:{id:"byte-n-x"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#byte-n-x"}},[t._v("#")]),t._v(" byte(n, x)")]),t._v(" "),e("h4",{attrs:{id:"pop-x"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pop-x"}},[t._v("#")]),t._v(" pop(x)")]),t._v(" "),e("h3",{attrs:{id:"call-相关"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#call-相关"}},[t._v("#")]),t._v(" call 相关")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("操作符号")]),t._v(" "),e("th",[t._v("返回值")]),t._v(" "),e("th",[t._v("版本")]),t._v(" "),e("th",[t._v("解释说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("calldataload(p)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("从位置 p 开始调用数据 (32 bytes)")])]),t._v(" "),e("tr",[e("td",[t._v("calldatasize()")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("调用数据的大小（以字节为单位）")])]),t._v(" "),e("tr",[e("td",[t._v("calldatacopy(t, f, s)")]),t._v(" "),e("td",[t._v("-")]),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("从位置 f 的 calldata 复制 s 个字节到位置 t 的内存")])]),t._v(" "),e("tr",[e("td",[t._v("call(g, a, v, in, insize, out, outsize)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("在地址 a 调用合约 "),e("a",{attrs:{href:"#yul-call-return-area"}},[t._v("See more")])])]),t._v(" "),e("tr",[e("td",[t._v("callcode(g, a, v, in, insize, out, outsize)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("与 "),e("code",[t._v("call")]),t._v(" 相同，但仅使用 a 中的代码，否则留在当前合约的上下文中 "),e("a",{attrs:{href:"#yul-call-return-area"}},[t._v("See more")])])]),t._v(" "),e("tr",[e("td",[t._v("delegatecall(g, a, in, insize, out, outsize)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("H")]),t._v(" "),e("td",[t._v("与 "),e("code",[t._v("callcode")]),t._v(" 相同，但也保留 "),e("code",[t._v("caller")]),t._v(" 和 "),e("code",[t._v("callvalue")]),t._v(" "),e("a",{attrs:{href:"#yul-call-return-area"}},[t._v("See more")])])]),t._v(" "),e("tr",[e("td",[t._v("staticcall(g, a, in, insize, out, outsize)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("B")]),t._v(" "),e("td",[t._v("与 "),e("code",[t._v("call(g, a, 0, in, insize, out, outsize)")]),t._v(" 相同，但不允许状态修改 ons "),e("a",{attrs:{href:"#yul-call-return-area"}},[t._v("See more")])])])])]),t._v(" "),e("h3",{attrs:{id:"结束执行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#结束执行"}},[t._v("#")]),t._v(" 结束执行")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("操作符号")]),t._v(" "),e("th",[t._v("返回值")]),t._v(" "),e("th",[t._v("版本")]),t._v(" "),e("th",[t._v("解释说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("return(p, s)")]),t._v(" "),e("td",[t._v("-")]),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("结束执行, return data mem[p…(p+s))")])]),t._v(" "),e("tr",[e("td",[t._v("stop()")]),t._v(" "),e("td",[t._v("-")]),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("结束执行, 类似 "),e("code",[t._v("return(0, 0)")])])]),t._v(" "),e("tr",[e("td",[t._v("revert(p, s)")]),t._v(" "),e("td",[t._v("-")]),t._v(" "),e("td",[t._v("B")]),t._v(" "),e("td",[t._v("结束执行, revert state changes, return data mem[p…(p+s))")])]),t._v(" "),e("tr",[e("td",[t._v("selfdestruct(a)")]),t._v(" "),e("td",[t._v("-")]),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("结束执行, destroy current contract and send funds to a")])]),t._v(" "),e("tr",[e("td",[t._v("invalid()")]),t._v(" "),e("td",[t._v("-")]),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("结束执行 with invalid instruction")])]),t._v(" "),e("tr",[e("td",[t._v("returndatasize()")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("B")]),t._v(" "),e("td",[t._v("最后返回数据的大小")])]),t._v(" "),e("tr",[e("td",[t._v("returndatacopy(t, f, s)")]),t._v(" "),e("td",[t._v("-")]),t._v(" "),e("td",[t._v("B")]),t._v(" "),e("td",[t._v("将 s 个字节从位置 f 的 returndata 复制到位置 t 的 mem")])])])]),t._v(" "),e("h3",{attrs:{id:"log-信息"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#log-信息"}},[t._v("#")]),t._v(" log 信息")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("操作符号")]),t._v(" "),e("th",[t._v("返回值")]),t._v(" "),e("th",[t._v("版本")]),t._v(" "),e("th",[t._v("解释说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("log0(p, s)")]),t._v(" "),e("td",[t._v("-")]),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("log without topics and data mem[p…(p+s))")])]),t._v(" "),e("tr",[e("td",[t._v("log1(p, s, t1)")]),t._v(" "),e("td",[t._v("-")]),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("log with topic t1 and data mem[p…(p+s))")])]),t._v(" "),e("tr",[e("td",[t._v("log2(p, s, t1, t2)")]),t._v(" "),e("td",[t._v("-")]),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("log with topics t1, t2 and data mem[p…(p+s))")])]),t._v(" "),e("tr",[e("td",[t._v("log3(p, s, t1, t2, t3)")]),t._v(" "),e("td",[t._v("-")]),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("log with topics t1, t2, t3 and data mem[p…(p+s))")])]),t._v(" "),e("tr",[e("td",[t._v("log4(p, s, t1, t2, t3, t4)")]),t._v(" "),e("td",[t._v("-")]),t._v(" "),e("td",[t._v("F")]),t._v(" "),e("td",[t._v("log with topics t1, t2, t3, t4 and data mem[p…(p+s))")])])])]),t._v(" "),e("h2",{attrs:{id:"🆗-实战应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#🆗-实战应用"}},[t._v("#")]),t._v(" 🆗 实战应用")]),t._v(" "),e("h3",{attrs:{id:"例子-1-一个演示"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#例子-1-一个演示"}},[t._v("#")]),t._v(" 例子 1:一个演示")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("library VectorSum {\n    // 此函数效率较低，因为优化器当前无法删除数组访问中的边界检查。\n    function sumSolidity(uint256[] memory data)\n        public\n        pure\n        returns (uint256 sum)\n    {\n        for (uint256 i = 0; i < data.length; ++i) sum += data[i];\n    }\n\n    // We know that we only access the array in bounds, so we can avoid the check.\n    // 0x20 needs to be added to an array because the first slot contains the\n    // array length.\n    // 我们知道我们只在边界内访问数组，\n    // 所以我们可以避免检查。0x20 需要添加到数组，因为第一个槽包含数组长度。\n    function sumAsm(uint256[] memory data) public pure returns (uint256 sum) {\n        for (uint256 i = 0; i < data.length; ++i) {\n            assembly {\n                sum := add(sum, mload(add(add(data, 0x20), mul(i, 0x20))))\n            }\n        }\n    }\n\n    // Same as above, but accomplish the entire code within inline assembly.\n    function sumPureAsm(uint256[] memory data)\n        public\n        pure\n        returns (uint256 sum)\n    {\n        assembly {\n            // Load the length (first 32 bytes)\n            let len := mload(data)\n\n            // Skip over the length field.\n            //\n            // Keep temporary variable so it can be incremented in place.\n            //\n            // NOTE: incrementing data would result in an unusable\n            //       data variable after this assembly block\n            let dataElementLocation := add(data, 0x20)\n\n            // Iterate until the bound is not met.\n            for {\n                let end := add(dataElementLocation, mul(len, 0x20))\n            } lt(dataElementLocation, end) {\n                dataElementLocation := add(dataElementLocation, 0x20)\n            } {\n                sum := add(sum, mload(dataElementLocation))\n            }\n        }\n    }\n}\n\n")])])]),e("h3",{attrs:{id:"例子-2-获取合约代码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#例子-2-获取合约代码"}},[t._v("#")]),t._v(" 例子 2:获取合约代码")]),t._v(" "),e("p",[t._v("gas 相差无几，重点看一下 code 的背后原理")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ncontract Demo {\n    // 24310 gas\n    function codeBySolidity(address _addr)\n        public\n        view\n        returns (bytes memory o_code)\n    {\n        return _addr.code;\n    }\n\n    // 24286 gas\n    function codeByAssembly(address _addr)\n        public\n        view\n        returns (bytes memory o_code)\n    {\n        assembly {\n            // 1.使用 extcodesize 获取合约内的代码大小\n            let size := extcodesize(_addr)\n\n            // 2.使用 mload 分配输出字节数组\n            // 类似 o_code = new bytes（size）\n            o_code := mload(0x40)\n\n            // 在 0x40 的位置存入数据\n            //      add(size, 0x20) :\n            //              size 加 0x20\n            //      add(add(size, 0x20), 0x1f)\n            //              size 加 0x20,再加 0x1f\n            //      not(0x1f)\n            //              0x1f 的按位非\n            //      and(add(add(size, 0x20), 0x1f), not(0x1f))\n            //          "size 加 0x20,再加 0x1f" 和 "0x1f的按位非" 的按位与\n            mstore(\n                0x40,\n                add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f)))\n            )\n\n            // 把长度保存到内存中\n            mstore(o_code, size)\n\n            // 实际获取代码，这需要汇编语言\n            extcodecopy(_addr, add(o_code, 0x20), 0, size)\n        }\n    }\n}\n')])])]),e("h3",{attrs:{id:"例子-3-计算数值数组的和"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#例子-3-计算数值数组的和"}},[t._v("#")]),t._v(" 例子 3:计算数值数组的和")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nlibrary VectorSum {\n    // 因为目前的优化器在访问数组时无法移除边界检查，\n    // 所以这个函数的执行效率比较低。\n    function sumSolidity(uint256[] memory _data)\n        public\n        pure\n        returns (uint256 o_sum)\n    {\n        for (uint256 i = 0; i < _data.length; ++i) o_sum += _data[i];\n    }\n\n    // 我们只能在数组范围内访问数组元素，所以我们可以在内联汇编中不做边界检查。\n    // 由于 ABI 编码中数组数据的第一个字（32 字节）的位置保存的是数组长度，\n    // 所以我们在访问数组元素时需要加入 0x20 作为偏移量。\n    function sumAsm(uint256[] memory _data)\n        public\n        pure\n        returns (uint256 o_sum)\n    {\n        for (uint256 i = 0; i < _data.length; ++i) {\n            assembly {\n                o_sum := add(o_sum, mload(add(add(_data, 0x20), mul(i, 0x20))))\n            }\n        }\n    }\n\n    // 和上面一样，但在内联汇编内完成整个代码。\n    function sumPureAsm(uint256[] memory _data)\n        public\n        pure\n        returns (uint256 o_sum)\n    {\n        assembly {\n            // 取得数组长度（取前 32 字节）\n            let len := mload(_data)\n\n            // 略过长度字段。\n            //\n            // 保持临时变量以便它可以在原地增加。\n            //\n            // 注意：对 _data 数值的增加将导致 _data 在这个汇编语句块之后不再可用。\n            //      因为无法再基于 _data 来解析后续的数组数据。\n            let data := add(_data, 0x20)\n\n            // 迭代到数组数据结束\n            for {\n                let end := add(data, mul(len, 0x20))\n            } lt(data, end) {\n                data := add(data, 0x20)\n            } {\n                o_sum := add(o_sum, mload(data))\n            }\n        }\n    }\n}\n")])])]),e("h2",{attrs:{id:"️⃣-问答题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#️⃣-问答题"}},[t._v("#")]),t._v(" #️⃣ 问答题")]),t._v(" "),e("ul",[e("li",[t._v("Assembly（内联汇编）与普通 Solidity 代码有什么区别？\n"),e("ul",[e("li",[t._v("使用内联汇编，可以在 Solidity 源程序中嵌入汇编代码，对 EVM 有更细粒度的控制。")])])]),t._v(" "),e("li",[t._v("Assembly（内联汇编）的作用？\n"),e("ul",[e("li",[t._v("内联汇编主要用在编写库函数时很有用，一般用于写工具函数，比如椭圆签名解析等。")])])]),t._v(" "),e("li",[t._v("Assembly（内联汇编）的常见方法有，作用分别是什么？\n"),e("ul",[e("li",[e("code",[t._v(":=")])]),t._v(" "),e("li",[e("code",[t._v("add")])]),t._v(" "),e("li",[e("code",[t._v("mload")])]),t._v(" "),e("li",[e("code",[t._v("mul")])]),t._v(" "),e("li",[e("code",[t._v("0x20")]),t._v(" / "),e("code",[t._v("0x40")])])])]),t._v(" "),e("li",[t._v("问题：内存数据 mload 时为什么从第 32 位开始?")])])])}),[],!1,null,null,null);e.default=s.exports}}]);