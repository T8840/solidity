(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{447:function(e,n,t){"use strict";t.r(n);var r=t(2),a=Object(r.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_13-interface-接口"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_13-interface-接口"}},[e._v("#")]),e._v(" 13.interface:接口")]),e._v(" "),n("p",[e._v("很多时候，我们需要调用已经部署在链上的已经合约，这时候可以通过接口合约实现部分调用的逻辑，我们只需要写一个与之对应的接口合约，就可以调用了。")]),e._v(" "),n("p",[e._v("在 solidity 语言中，只要某个合约有和接口种相同的函数声明，就可以被此合约所接受。接口就是起到一个桥接的作用；类似手机的接口，只要匹配，可以进行充电，也可以进行听歌。")]),e._v(" "),n("p",[n("code",[e._v("interface")]),e._v(" 类似于"),n("RouterLink",{attrs:{to:"/source/10.inheritance.html#abstract"}},[e._v("抽象合约")]),e._v(" ，但它们不能实现任何功能。还有其他限制。 "),n("code",[e._v("interface")]),e._v("内的函数被隐式标记为"),n("code",[e._v("virtual")])],1),e._v(" "),n("h2",{attrs:{id:"_1️⃣-限制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1️⃣-限制"}},[e._v("#")]),e._v(" 1️⃣ 限制")]),e._v(" "),n("ul",[n("li",[e._v("无法实现任何功能，没有函数体。")]),e._v(" "),n("li",[e._v("无法定义构造函数。")]),e._v(" "),n("li",[e._v("无法定义状态变量。")]),e._v(" "),n("li",[e._v("无法定义结构（"),n("code",[e._v("strct")]),e._v("）（"),n("code",[e._v("0.5.0")]),e._v(" 版本开始接口里可以支持声明 "),n("code",[e._v("enum")]),e._v(" 类型）。")]),e._v(" "),n("li",[e._v("不可以声明修改器。")]),e._v(" "),n("li",[e._v("所有声明的函数必须是 "),n("code",[e._v("external")]),e._v(" 的，尽管在合约里可以是 public\n"),n("ul",[n("li",[e._v("文档说：将来可能会解除这里的某些限制。")])])])]),e._v(" "),n("p",[e._v("⚠️ 注意： interface 可以基于别的 interface，可以继承其他合约。比如 "),n("code",[e._v("interface IERC20Metadata is IERC20{}")]),e._v(",定义 "),n("code",[e._v("IERC20Metadata")]),e._v(" 基于 "),n("code",[e._v("IERC20")]),e._v(" 接口。")]),e._v(" "),n("h2",{attrs:{id:"_2️⃣-定义和使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2️⃣-定义和使用"}},[e._v("#")]),e._v(" 2️⃣ 定义和使用")]),e._v(" "),n("p",[e._v("接口需要有 interface 关键字，并且内部只需要有函数的声明，不用实现。只要某合约中有和词接口相同的函数声明，就可以被此合约所接受。语法如下")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("interface 接口名{\n    函数声明;\n}\n")])])]),n("p",[e._v("接口基本上仅限于合约 ABI 可以表示的内容，并且 ABI 和接口之间的转换不应该丢失任何信息。")]),e._v(" "),n("p",[e._v("在下面的例子中，定义了 cat 合约以及 dog 合约。他们都有 eat 方法.以此他们都可以被上面的 animalEat 接口所接收。")]),e._v(" "),n("h3",{attrs:{id:"使用例子"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用例子"}},[e._v("#")]),e._v(" 使用例子")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Cat {\n    uint256 public age;\n\n    function eat() public returns (string memory) {\n        age++;\n        return "cat eat fish";\n    }\n\n    function sleep1() public pure returns (string memory) {\n        return "sleep1";\n    }\n}\n\ncontract Dog {\n    uint256 public age;\n\n    function eat() public returns (string memory) {\n        age += 2;\n        return "dog miss you";\n    }\n\n    function sleep2() public pure returns (string memory) {\n        return "sleep2";\n    }\n}\n\ninterface AnimalEat {\n    function eat() external returns (string memory);\n}\n\ncontract Animal {\n    function test(address _addr) external returns (string memory) {\n        AnimalEat general = AnimalEat(_addr);\n        return general.eat();\n    }\n}\n')])])]),n("p",[e._v("测试流程:")]),e._v(" "),n("ol",[n("li",[e._v("部署 Cat 合约")]),e._v(" "),n("li",[e._v("部署 Dog 合约")]),e._v(" "),n("li",[e._v("部署 Animal 合约")]),e._v(" "),n("li",[e._v("调用 "),n("code",[e._v("Animal.test")]),e._v(",参数是 Cat 合约地址\n"),n("ol",[n("li",[e._v("返回 "),n("code",[e._v('"string: cat eat fish"')])]),e._v(" "),n("li",[e._v("在 Cat 合约内查看 "),n("code",[e._v("age")]),e._v(" 返回的数字")])])]),e._v(" "),n("li",[e._v("调用 "),n("code",[e._v("Animal.test")]),e._v(",参数是 Dog 合约地址\n"),n("ol",[n("li",[e._v("返回 "),n("code",[e._v('"string: dog miss you"')])]),e._v(" "),n("li",[e._v("在 Dog 合约内查看 "),n("code",[e._v("age")]),e._v(" 返回的数字")])])])]),e._v(" "),n("p",[e._v("在合约 Animal 中，调用函数 test，如果传递的是部署的 Cat 的合约地址，那么我们在调用接口的 eat 方法时，实则调用了 Cat 合约的 eat 方法。 同理，如果传递的是部署的 Dog 的合约地址，那么我们在调用接口的 eat 方法时，实则调用了 dog 合约的 eat 方法。")]),e._v(" "),n("h3",{attrs:{id:"隐式的标记为virtual"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#隐式的标记为virtual"}},[e._v("#")]),e._v(" 隐式的标记为"),n("code",[e._v("virtual")])]),e._v(" "),n("p",[e._v("就像继承其他合约一样，合约可以继承接口。接口中的函数都会隐式的标记为\n"),n("code",[e._v("virtual")]),e._v(" ，意味着他们会被重写并不需要 "),n("code",[e._v("override")]),e._v(" 关键字。\n但是不表示重写（overriding）函数可以再次重写，仅仅当重写的函数标记为\n"),n("code",[e._v("virtual")]),e._v(" 才可以再次重写。")]),e._v(" "),n("p",[e._v("接口可以继承其他的接口，遵循同样继承规则。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface ParentA {\n    function test() external returns (uint256);\n}\n\ninterface ParentB {\n    function test() external returns (uint256);\n}\n\ninterface SubInterface is ParentA, ParentB {\n    // 必须重新定义 test 函数，以表示兼容父合约含义\n    function test() external override(ParentA, ParentB) returns (uint256);\n}\n")])])]),n("h2",{attrs:{id:"_3️⃣-全局属性-type-i-interfaceid"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3️⃣-全局属性-type-i-interfaceid"}},[e._v("#")]),e._v(" 3️⃣ 全局属性 "),n("code",[e._v("type(I).interfaceId")])]),e._v(" "),n("p",[e._v("返回接口"),n("code",[e._v("I")]),e._v(" 的 bytes4 类型的接口 ID，接口 ID 参考： EIP-165 定义的， 接口 ID 被定义为 XOR （异或） 接口内所有的函数的函数选择器（除继承的函数。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface ParentA {\n    function test() external returns (uint256);\n}\n\ncontract Demo {\n    function interfaceId() public pure returns (bytes4) {\n        return type(ParentA).interfaceId;\n    }\n}\n")])])]),n("h2",{attrs:{id:"_4️⃣-erc20-标准"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4️⃣-erc20-标准"}},[e._v("#")]),e._v(" 4️⃣ ERC20 标准")]),e._v(" "),n("h3",{attrs:{id:"标准"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#标准"}},[e._v("#")]),e._v(" 标准")]),e._v(" "),n("p",[n("strong",[e._v("问题: 如何判断一个 Token 合约是否为标准的 ERC20 合约？")])]),e._v(" "),n("ul",[n("li",[e._v("只要含有 ERC20 接口规定的所有内容，就算标准的 ERC20 合约。\n"),n("ul",[n("li",[e._v("至于方法内的逻辑是如何实现的，是不做判断。")])])])]),e._v(" "),n("p",[e._v("详情参考: https://eips.ethereum.org/EIPS/eip-20")]),e._v(" "),n("h3",{attrs:{id:"标准-erc20-接口"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#标准-erc20-接口"}},[e._v("#")]),e._v(" 标准 ERC20 接口")]),e._v(" "),n("ul",[n("li",[e._v("3 个查询\n"),n("ul",[n("li",[n("code",[e._v("balanceOf")]),e._v(": 查询指定地址的 Token 数量")]),e._v(" "),n("li",[n("code",[e._v("totalSupply")]),e._v(": 查询当前合约的 Token 总量")]),e._v(" "),n("li",[n("code",[e._v("allowance")]),e._v(": 查询指定地址对另外一个地址的剩余授权额度")])])]),e._v(" "),n("li",[e._v("2 个交易\n"),n("ul",[n("li",[n("code",[e._v("transfer")]),e._v(": 从当前调用者地址发送指定数量的 Token 到指定地址。\n"),n("ul",[n("li",[e._v("这是一个写入方法，所以还会抛出一个 "),n("code",[e._v("Transfer")]),e._v(" 事件。")])])]),e._v(" "),n("li",[n("code",[e._v("transferFrom")]),e._v(": 当向另外一个合约地址存款时，对方合约必须调用 transferFrom 才可以把 Token 拿到它自己的合约中。")])])]),e._v(" "),n("li",[e._v("2 个事件\n"),n("ul",[n("li",[n("code",[e._v("Transfer")])]),e._v(" "),n("li",[n("code",[e._v("Approval")])])])]),e._v(" "),n("li",[e._v("1 个授权\n"),n("ul",[n("li",[n("code",[e._v("approve")]),e._v(": 授权指定地址可以操作调用者的最大 Token 数量。")])])])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IERC20 {\n    // 1个授权\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    // 2个事件\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 amount\n    );\n\n    // 2个交易\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    // 3个查询\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n}\n")])])]),n("h3",{attrs:{id:"erc20-标准合约实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#erc20-标准合约实现"}},[e._v("#")]),e._v(" ERC20 标准合约实现")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IERC20 {\n    // 1个授权\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    // 2个事件\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 amount\n    );\n\n    // 2个交易\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    // 3个查询\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n}\n\ncontract ERC20 is IERC20 {\n    // 状态变量\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n\n    address public immutable owner;\n\n    // uint256 public immutable totalSupply; // 不增加总量\n    uint256 public totalSupply; // 总价总量\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    // 函数修改器\n    modifier onlyOwner() {\n        require(msg.sender == owner, "not owner");\n        _;\n    }\n\n    // 构造函数\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint256 _totalSupply\n    ) {\n        owner = msg.sender;\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        totalSupply = _totalSupply;\n        balanceOf[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    // 1个授权\n    function approve(address spender, uint256 amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    // 2个交易\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool)\n    {\n        balanceOf[msg.sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool) {\n        // msg.sender 也就是当前调用者，是被批准者\n        allowance[sender][msg.sender] -= amount;\n        balanceOf[sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    // 1个铸币 - 非必须\n    function mint(uint256 amount) external onlyOwner returns (bool) {\n        totalSupply += amount;\n        balanceOf[msg.sender] += amount;\n        emit Transfer(address(0), msg.sender, amount);\n        return true;\n    }\n\n    // 1个销毁 - 非必须\n    function burn(uint256 amount) external returns (bool) {\n        totalSupply -= amount;\n        balanceOf[msg.sender] -= amount;\n        emit Transfer(msg.sender, address(0), amount);\n        return true;\n    }\n\n    // 转移 owner 权限等其他一些操作均是看各自业务，非必需的\n}\n')])])]),n("h2",{attrs:{id:"_5️⃣-erc721-标准"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5️⃣-erc721-标准"}},[e._v("#")]),e._v(" 5️⃣ ERC721 标准")]),e._v(" "),n("p",[e._v("参考资料:")]),e._v(" "),n("ul",[n("li",[e._v("https://eips.ethereum.org/EIPS/eip-721")]),e._v(" "),n("li",[e._v("https://ethereum.org/zh/developers/docs/standards/tokens/erc-721/")])]),e._v(" "),n("h3",{attrs:{id:"场景说明"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#场景说明"}},[e._v("#")]),e._v(" 场景说明")]),e._v(" "),n("p",[e._v("非同质化代币（NFT）用于以唯一的方式标识某人或者某物。 此类型的代币可以被完美地用于出售下列物品的平台：收藏品、密钥、彩票、音乐会座位编号、体育比赛等。 这种类型的代币有着惊人的潜力，因此它需要一个适当的标准。ERC-721 就是为解决这个问题而来！")]),e._v(" "),n("p",[e._v("所有 NFTs 都有一个 "),n("code",[e._v("uint256")]),e._v(" 变量，名为 "),n("code",[e._v("tokenId")]),e._v("，所以对于任何 ERC-721 合约，这对值 "),n("code",[e._v("contract address, tokenId")]),e._v(" 必须是全局唯一的。 也就是说，去中心化应用程序可以有一个“转换器”， 使用 tokenId 作为输入并输出一些很酷的事物图像，例如僵尸、武器、技能或神奇的小猫咪！")]),e._v(" "),n("h3",{attrs:{id:"合约代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#合约代码"}},[e._v("#")]),e._v(" 合约代码")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC165 标准的接口 https://eips.ethereum.org/EIPS/eip-165\n * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified\n */\ninterface IERC165 {\n    /// @notice 查询合约是否实现接口\n    /// @param interfaceID ERC-165 中指定的接口标识符\n    /// @dev 接口标识在 ERC-165 中指定。此功能需要低于 30,000 gas。\n    /// @return 如果合约实现了 interfaceID 且 interfaceID 不是 0xffffffff，则为 true，否则为 false\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\ninterface IERC721 is IERC165 {\n    /**\n     @dev 当任何 NFT 的所有权通过任何形式发生变化时，需要触发该事件。\n     当 NFT 创建（`from` == 0）和销毁（`to` == 0）时会触发此事件。\n     例外情况：在合约创建期间，可以创建和分配任意数量的 NFT，而不会发出 Transfer。\n     在任何形式的资产转移时，该 NFT如果有批准地址将重置为无。\n    */\n    event Transfer(\n        address indexed _from,\n        address indexed _to,\n        uint256 indexed _tokenId\n    );\n\n    /**\n     * 当 NFT 的批准地址被更改或重新确认时，它会发出。\n     * 零地址表示没有批准的地址。\n     * 当 Transfer 事件发出时，这也表明该 NFT 如果有批准地址被重置为无。\n     */\n    event Approval(\n        address indexed _owner,\n        address indexed _approved,\n        uint256 indexed _tokenId\n    );\n\n    /// @dev 当为所有者启用或禁用操作员时，它会发出。 运营者可以管理所有者的所有 NFT。\n    event ApprovalForAll(\n        address indexed _owner,\n        address indexed _operator,\n        bool _approved\n    );\n\n    /// @notice 所有者的 NFT 数量\n    /// @dev 分配给零地址的 NFT 被认为是无效的，并且该函数抛出有关零地址的查询。\n    /// @param _owner 查询余额的地址\n    /// @return `_owner` 拥有的 NFT 数量，可能为零\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice 找到 NFT 的所有者\n    /// @dev 分配给零地址的 NFT 被认为是无效的，并且对它们的查询确实会抛出异常。\n    /// @param _tokenId NFT 的标识符\n    /// @return NFT所有者的地址\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n    /// @notice 将 NFT 的所有权从一个地址转移到另一个地址\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n    ///  `onERC721Received` on `_to` and throws if the return value is not\n    ///  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.\n    /// @param _from NFT的当前所有者\n    /// @param _to 新 owner\n    /// @param _tokenId 转移的 NFT\n    /// @param data 没有指定格式的附加数据，在调用 _to 时发送\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes calldata data\n    ) external payable;\n\n    /// @notice 将 NFT 的所有权从一个地址转移到另一个地址\n    /// @dev 这与具有额外数据参数的其他函数的工作方式相同，只是此函数只是将数据设置为“”。\n    /// @param _from NFT的当前所有者\n    /// @param _to 新 owner\n    /// @param _tokenId 转移的 NFT\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external payable;\n\n    /// @notice 转移 NFT 的所有权——调用者有责任确认 `_to` 能够接收 NFTS，否则它们可能会永久丢失\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT.\n    /// @param _from NFT的当前所有者\n    /// @param _to 新 owner\n    /// @param _tokenId 转移的 NFT\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external payable;\n\n    /// @notice 更改或重申 NFT 的批准地址\n    /// @dev The zero address indicates there is no approved address.\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n    ///  operator of the current owner.\n    /// @param _approved 新批准的 NFT 控制器\n    /// @param _tokenId NFT 批准\n    function approve(address _approved, uint256 _tokenId) external payable;\n\n    /// @notice 启用或禁用对第三方（“操作员”）的批准以管理所有 `msg.sender` 的资产\n    /// @dev 发出 ApprovalForAll 事件。 合同必须允许每个所有者有多个操作员。\n    /// @param _operator 添加到授权运营商集中的地址\n    /// @param _approved 如果运营商获得批准，则为 True，如果撤消批准，则为 false\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /// @notice 获取单个 NFT 的认可地址\n    /// @dev 如果 _tokenId 不是有效的 NFT，则抛出。\n    /// @param _tokenId NFT寻找批准的地址\n    /// @return 此 NFT 的批准地址，如果没有则为零地址\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n    /// @notice 查询一个地址是否是另一个地址的授权操作员\n    /// @param _owner 拥有 NFT 的地址\n    /// @param _operator 代表所有者的地址\n    /// @return 如果 _operator 是 _owner 的批准运算符，则为真，否则为假\n    function isApprovedForAll(address _owner, address _operator)\n        external\n        view\n        returns (bool);\n}\n')])])]),n("h2",{attrs:{id:"_6️⃣-erc1155-标准"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6️⃣-erc1155-标准"}},[e._v("#")]),e._v(" 6️⃣ ERC1155 标准")]),e._v(" "),n("p",[e._v("参考资料:")]),e._v(" "),n("ul",[n("li",[e._v("https://eips.ethereum.org/EIPS/eip-1155")]),e._v(" "),n("li",[e._v("https://ethereum.org/zh/developers/docs/standards/tokens/erc-1155/")])]),e._v(" "),n("h3",{attrs:{id:"场景说明-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#场景说明-2"}},[e._v("#")]),e._v(" 场景说明")]),e._v(" "),n("p",[e._v("用于多种代币管理的合约标准接口。单个部署的合约可以包括同质化代币、非同质化代币或其他配置（如半同质化代币）的任何组合。")]),e._v(" "),n("p",[e._v("它的目的很单纯，就是创建一个智能合约接口，可以代表和控制任何数量的同质化和非同质化代币类型。 这样一来，ERC-1155 代币就具有与 ERC-20 和 ERC-721 代币相同的功能，甚至可以同时使用这两者的功能。 而最重要的是，它能改善这两种标准的功能，使其更有效率，并纠正 ERC-20 和 ERC-721 标准上明显的实施错误。")]),e._v(" "),n("h3",{attrs:{id:"合约代码-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#合约代码-2"}},[e._v("#")]),e._v(" 合约代码")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC165 标准的接口 https://eips.ethereum.org/EIPS/eip-165\n * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified\n */\ninterface IERC165 {\n    /// @notice 查询合约是否实现接口\n    /// @param interfaceID ERC-165 中指定的接口标识符\n    /// @dev 接口标识在 ERC-165 中指定。此功能需要低于 30,000 gas。\n    /// @return 如果合约实现了 interfaceID 且 interfaceID 不是 0xffffffff，则为 true，否则为 false\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n\n/**\n    @title ERC-1155 Multi Token Standard\n    @dev See https://eips.ethereum.org/EIPS/eip-1155\n    Note: The ERC-165 identifier for this interface is 0xd9b67a26.\n */\ninterface IERC1155 is IERC165 {\n    /**\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred,\n        including zero value transfers as well as minting or burning (see "Safe Transfer Rules" section of the standard).\n        The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\n        The `_id` argument MUST be the token type being transferred.\n        The `_value` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\n    */\n    event TransferSingle(\n        address indexed _operator,\n        address indexed _from,\n        address indexed _to,\n        uint256 _id,\n        uint256 _value\n    );\n\n    /**\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred,\n        including zero value transfers as well as minting or burning (see "Safe Transfer Rules" section of the standard).\n        The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\n        The `_ids` argument MUST be the list of tokens being transferred.\n        The `_values` argument MUST be the list of number of tokens (matching the list and order of tokens specified in _ids)\n        the holder balance is decreased by and match what the recipient balance is increased by.\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\n    */\n    event TransferBatch(\n        address indexed _operator,\n        address indexed _from,\n        address indexed _to,\n        uint256[] _ids,\n        uint256[] _values\n    );\n\n    /**\n        @dev 必须在批准第二方/运营商地址管理所有者地址的所有令牌时启用或禁用（没有事件假定禁用）\n    */\n    event ApprovalForAll(\n        address indexed _owner,\n        address indexed _operator,\n        bool _approved\n    );\n\n    /**\n        @dev 必须在为令牌 ID 更新 URI 时发出。\n        URI 在 RFC 3986 中定义。\n        URI 必须指向符合“ERC-1155 元数据 URI JSON 模式”的 JSON 文件。\n    */\n    event URI(string _value, uint256 indexed _id);\n\n    /**\n        @notice Transfers `_value` amount of an `_id` from the `_from` address\n                to the `_to` address specified (with safety call).\n        @dev Caller must be approved to manage the tokens being transferred\n        out of the `_from` account (see "Approval" section of the standard).\n        MUST revert if `_to` is the zero address.\n        MUST revert if balance of holder for token `_id` is lower than the `_value` sent.\n        MUST revert on any other error.\n        MUST emit the `TransferSingle` event to reflect the balance change (see "Safe Transfer Rules" section of the standard).\n        After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so,\n        it MUST call `onERC1155Received` on `_to` and act appropriately (see "Safe Transfer Rules" section of the standard).\n        @param _from    Source address\n        @param _to      Target address\n        @param _id      ID of the token type\n        @param _value   Transfer amount\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`\n    */\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata _data\n    ) external;\n\n    /**\n        @notice 将 `_ids` 的 `_values` 数量从 `_from` 地址转移到指定的 `_to` 地址（使用安全调用）。\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see "Approval" section of the standard).\n        MUST revert if `_to` is the zero address.\n        MUST revert if length of `_ids` is not the same as length of `_values`.\n        MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.\n        MUST revert on any other error.\n        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see "Safe Transfer Rules" section of the standard).\n        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\n        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so,\n        it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see "Safe Transfer Rules" section of the standard).\n        @param _from    Source address\n        @param _to      Target address\n        @param _ids     每个令牌类型的 ID（顺序和长度必须匹配 _values 数组）\n        @param _values  每种代币类型的转账金额（顺序和长度必须匹配 _ids 数组）\n        @param _data    没有指定格式的额外数据，必须在调用 _to 上的 `ERC1155TokenReceiver` 钩子时原封不动地发送\n    */\n    function safeBatchTransferFrom(\n        address _from,\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes calldata _data\n    ) external;\n\n    /**\n        @notice 获取帐户令牌的余额。\n        @param _owner  令牌持有者的地址\n        @param _id     ID of the token\n        @return        请求的代币类型的所有者余额\n     */\n    function balanceOf(address _owner, uint256 _id)\n        external\n        view\n        returns (uint256);\n\n    /**\n        @notice 获取多个账户/代币对的余额\n        @param _owners 代币持有者的地址\n        @param _ids    ID of the tokens\n        @return        请求的令牌类型的 _owner 余额（即每个 (owner, id) 对的余额）\n     */\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n        @notice 启用或禁用对第三方（“操作员”）的批准以管理所有调用者的令牌。\n        @dev 必须在成功时发出 ApprovalForAll 事件。\n        @param _operator  添加到授权运营商集中的地址\n        @param _approved  如果运营商获得批准，则为 True，如果撤消批准，则为 false\n    */\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /**\n        @notice 查询给定所有者的操作员的批准状态。\n        @param _owner     The owner of the tokens\n        @param _operator  授权操作员的地址\n        @return           如果操作员被批准则为真，否则为假\n    */\n    function isApprovedForAll(address _owner, address _operator)\n        external\n        view\n        returns (bool);\n}\n')])])]),n("h2",{attrs:{id:"_7️⃣-erc3525-标准"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_7️⃣-erc3525-标准"}},[e._v("#")]),e._v(" 7️⃣ ERC3525 标准")]),e._v(" "),n("p",[e._v("每个符合 EIP-3525 的合约都必须实现 EIP-3525、EIP-721 和 EIP-165 接口")]),e._v(" "),n("p",[e._v("参考资料:")]),e._v(" "),n("ul",[n("li",[e._v("https://eips.ethereum.org/EIPS/eip-3525")])]),e._v(" "),n("h3",{attrs:{id:"场景说明-3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#场景说明-3"}},[e._v("#")]),e._v(" 场景说明")]),e._v(" "),n("p",[e._v("描述一组具有相同类型，但是有轻微不同的东西。比如相同的 100 元人民币，一共 100 张，每一张都是价值 100 的纸币，大部分的防伪等等都不同，但是每一张都编号都不同。")]),e._v(" "),n("h3",{attrs:{id:"合约代码-3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#合约代码-3"}},[e._v("#")]),e._v(" 合约代码")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title EIP-3525 Semi-Fungible Token Standard\n * Note: the EIP-165 identifier for this interface is 0xd5358140.\n */\n\ninterface IERC3525  /* is IERC165, IERC721 */ {\n    /**\n     * @dev MUST emit when value of a token is transferred to another token with the same slot,\n     *  including zero value transfers (_value == 0) as well as transfers when tokens are created\n     *  (`_fromTokenId` == 0) or destroyed (`_toTokenId` == 0).\n     * @param _fromTokenId The token id to transfer value from\n     * @param _toTokenId The token id to transfer value to\n     * @param _value The transferred value\n     */\n    event TransferValue(\n        uint256 indexed _fromTokenId,\n        uint256 indexed _toTokenId,\n        uint256 _value\n    );\n\n    /**\n     * @dev MUST emit when the approval value of a token is set or changed.\n     * @param _tokenId The token to approve\n     * @param _operator The operator to approve for\n     * @param _value The maximum value that `_operator` is allowed to manage\n     */\n    event ApprovalValue(\n        uint256 indexed _tokenId,\n        address indexed _operator,\n        uint256 _value\n    );\n\n    /**\n     * @dev MUST emit when the slot of a token is set or changed.\n     * @param _tokenId The token of which slot is set or changed\n     * @param _oldSlot The previous slot of the token\n     * @param _newSlot The updated slot of the token\n     */\n    event SlotChanged(\n        uint256 indexed _tokenId,\n        uint256 indexed _oldSlot,\n        uint256 indexed _newSlot\n    );\n\n    /**\n     * @notice Get the number of decimals the token uses for value - e.g. 6, means the user\n     *  representation of the value of a token can be calculated by dividing it by 1,000,000.\n     *  Considering the compatibility with third-party wallets, this function is defined as\n     *  `valueDecimals()` instead of `decimals()` to avoid conflict with EIP-20 tokens.\n     * @return The number of decimals for value\n     */\n    function valueDecimals() external view returns (uint8);\n\n    /**\n     * @notice Get the value of a token.\n     * @param _tokenId The token for which to query the balance\n     * @return The value of `_tokenId`\n     */\n    function balanceOf(uint256 _tokenId) external view returns (uint256);\n\n    /**\n     * @notice Get the slot of a token.\n     * @param _tokenId The identifier for a token\n     * @return The slot of the token\n     */\n    function slotOf(uint256 _tokenId) external view returns (uint256);\n\n    /**\n     * @notice Allow an operator to manage the value of a token, up to the `_value`.\n     * @dev MUST revert unless caller is the current owner, an authorized operator, or the approved\n     *  address for `_tokenId`.\n     *  MUST emit the ApprovalValue event.\n     * @param _tokenId The token to approve\n     * @param _operator The operator to be approved\n     * @param _value The maximum value of `_toTokenId` that `_operator` is allowed to manage\n     */\n    function approve(\n        uint256 _tokenId,\n        address _operator,\n        uint256 _value\n    ) external payable;\n\n    /**\n     * @notice Get the maximum value of a token that an operator is allowed to manage.\n     * @param _tokenId The token for which to query the allowance\n     * @param _operator The address of an operator\n     * @return The current approval value of `_tokenId` that `_operator` is allowed to manage\n     */\n    function allowance(uint256 _tokenId, address _operator)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Transfer value from a specified token to another specified token with the same slot.\n     * @dev Caller MUST be the current owner, an authorized operator or an operator who has been\n     *  approved the whole `_fromTokenId` or part of it.\n     *  MUST revert if `_fromTokenId` or `_toTokenId` is zero token id or does not exist.\n     *  MUST revert if slots of `_fromTokenId` and `_toTokenId` do not match.\n     *  MUST revert if `_value` exceeds the balance of `_fromTokenId` or its allowance to the\n     *  operator.\n     *  MUST emit `TransferValue` event.\n     * @param _fromTokenId The token to transfer value from\n     * @param _toTokenId The token to transfer value to\n     * @param _value The transferred value\n     */\n    function transferFrom(\n        uint256 _fromTokenId,\n        uint256 _toTokenId,\n        uint256 _value\n    ) external payable;\n\n    /**\n     * @notice 转移将指定数量的代币到新地址。调用者应确认 _to 能够接收 EIP-3525 资产。\n     * @dev This function MUST create a new EIP-3525 token with the same slot for `_to`,\n     *  or find an existing token with the same slot owned by `_to`, to receive the transferred value.\n     *  MUST revert if `_fromTokenId` is zero token id or does not exist.\n     *  MUST revert if `_to` is zero address.\n     *  MUST revert if `_value` exceeds the balance of `_fromTokenId` or its allowance to the\n     *  operator.\n     *  MUST emit `Transfer` and `TransferValue` events.\n     * @param _fromTokenId The token to transfer value from\n     * @param _to The address to transfer value to\n     * @param _value The transferred value\n     * @return ID of the token which receives the transferred value\n     */\n    function transferFrom(\n        uint256 _fromTokenId,\n        address _to,\n        uint256 _value\n    ) external payable returns (uint256);\n}\n")])])]),n("h3",{attrs:{id:"扩展"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#扩展"}},[e._v("#")]),e._v(" 扩展")]),e._v(" "),n("p",[e._v("更多关于 3525 协议的内容，参考 https://cloud.tencent.com/developer/article/2155201")]),e._v(" "),n("h2",{attrs:{id:"_8️⃣-四种代币标准的对比"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_8️⃣-四种代币标准的对比"}},[e._v("#")]),e._v(" 8️⃣ 四种代币标准的对比")]),e._v(" "),n("p",[n("img",{attrs:{src:"/_static/13/01.jpeg",alt:""}})]),e._v(" "),n("p",[n("img",{attrs:{src:"/_static/13/02.jpeg",alt:""}})]),e._v(" "),n("p",[n("img",{attrs:{src:"/_static/13/03.jpeg",alt:""}})]),e._v(" "),n("p",[n("img",{attrs:{src:"/_static/13/04.jpeg",alt:""}})]),e._v(" "),n("h2",{attrs:{id:"🆗-实战-荷兰拍卖"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#🆗-实战-荷兰拍卖"}},[e._v("#")]),e._v(" 🆗 实战:荷兰拍卖")]),e._v(" "),n("h3",{attrs:{id:"原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[e._v("#")]),e._v(" 原理")]),e._v(" "),n("p",[e._v("拍卖 NFT")]),e._v(" "),n("ul",[n("li",[e._v("需要拥有 NFT")]),e._v(" "),n("li",[e._v("需要在 NFT 合约内对拍卖合约做 "),n("code",[e._v("aoorove")]),e._v(";")])]),e._v(" "),n("h3",{attrs:{id:"代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#代码"}},[e._v("#")]),e._v(" 代码")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IERC721 {\n    function transferFrom(\n        address _form,\n        address _to,\n        uint256 _nftId\n    ) external;\n}\n\ncontract DutchAuction {\n    uint256 private immutable duration;\n\n    address payable public immutable seller;\n\n    IERC721 public immutable nft;\n    uint256 public immutable nftId;\n\n    uint256 public immutable startingPrice;\n    uint256 public immutable startAt;\n    uint256 public immutable endAt;\n    uint256 public immutable discountRate;\n\n    constructor(\n        address _nft,\n        uint256 _nftId,\n        uint256 _startingPrice,\n        uint256 _duration,\n        uint256 _discountRate\n    ) {\n        require(\n            _startingPrice >= _duration * _discountRate,\n            "starting price < discount"\n        );\n        seller = payable(msg.sender);\n        nft = IERC721(_nft); // 需要 IERC721 进行转换\n        nftId = _nftId;\n        duration = _duration;\n        startingPrice = _startingPrice;\n        discountRate = _discountRate;\n\n        startAt = block.timestamp;\n        endAt = block.timestamp + _duration;\n    }\n\n    // 获取价格\n    function getPrice() public view returns (uint256) {\n        uint256 timeElapsed = block.timestamp - startAt;\n        uint256 discount = discountRate * timeElapsed;\n        return startingPrice - discount;\n    }\n\n    // 购买\n    function buy() external payable {\n        // 打包时间需要在拍卖截止之前\n        require(block.timestamp < endAt, "Auction has ended");\n\n        uint256 price = getPrice();\n        require(msg.value >= price, "Insufficient amount");\n        nft.transferFrom(seller, msg.sender, nftId);\n\n        // 如果有多余的钱，需要把钱退会购买者账号(提交时间和打包确认时间不一致)\n        uint256 refund = msg.value - price;\n        if (refund > 0) {\n            payable(msg.sender).transfer(refund);\n        }\n        selfdestruct(seller);\n    }\n}\n')])])]),n("h2",{attrs:{id:"🆗-实战-英式拍卖"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#🆗-实战-英式拍卖"}},[e._v("#")]),e._v(" 🆗 实战:英式拍卖")]),e._v(" "),n("h3",{attrs:{id:"原理-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原理-2"}},[e._v("#")]),e._v(" 原理")]),e._v(" "),n("p",[e._v("拍卖 NFT")]),e._v(" "),n("ul",[n("li",[e._v("需要拥有 NFT")]),e._v(" "),n("li",[e._v("需要在 NFT 合约内对拍卖合约做 "),n("code",[e._v("aoorove")]),e._v(";")])]),e._v(" "),n("h3",{attrs:{id:"代码-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#代码-2"}},[e._v("#")]),e._v(" 代码")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IERC721 {\n    function transferFrom(\n        address _form,\n        address _to,\n        uint256 _nftId\n    ) external;\n}\n\n// TODO: 区块注释信息，可以选择在合约完成后删除\ncontract HelloComrades {\n    /*\n     * ========================================\n     * State Variables\n     * ========================================\n     */\n\n    address payable public immutable seller;\n\n    IERC721 public immutable nft;\n    uint256 public immutable nftId;\n\n    uint32 public endAt; // 结束时间\n    bool public started; // 开始时间\n    bool public ended; // 结束时间\n\n    uint256 public highestBid; // 最高出价\n    address public highestBider; // 最高出价人\n    mapping(address => uint256) public bids; // 除了最高出价外的所有出价人\n\n    /*\n     * ========================================\n     * Events\n     * ========================================\n     */\n    event Start();\n    event End(address highestBider, uint256 amount);\n    event Bid(address indexed sender, uint256 amount);\n    event Withdraw(address indexed sender, uint256 amount);\n\n    /*\n     * ========================================\n     * Modifier\n     * ========================================\n     */\n\n    /*\n     * ========================================\n     * Errors\n     * ========================================\n     */\n\n    /*\n     * ========================================\n     * Constructor\n     * ========================================\n     */\n    constructor(\n        address _nft,\n        uint256 _nftId,\n        uint256 _startingPrice\n    ) {\n        seller = payable(msg.sender);\n        nft = IERC721(_nft); // 需要 IERC721 进行转换\n        nftId = _nftId;\n        highestBid = _startingPrice;\n    }\n\n    /*\n     * ========================================\n     * Functions\n     * ========================================\n     */\n    function start() external {\n        require(msg.sender == seller, "Nor seller");\n        require(!started, "started");\n\n        started = true;\n        endAt = uint32(block.timestamp + 60);\n        nft.transferFrom(seller, address(this), nftId);\n\n        emit Start();\n    }\n\n    function bid() external payable {\n        require(started, "Not started"); //需要时间已经开始\n        require(block.timestamp < endAt, "ended"); // 需要时间还没有过期\n        require(msg.value > highestBid, "invalid price"); // 需要高于上次出价\n\n        // 把上一次最高出价和出价人写入账本\n        if (highestBider != address(0)) {\n            bids[highestBider] += highestBid;\n        }\n\n        // 更新最高出价/最高出价人\n        highestBid = msg.value;\n        highestBider = msg.sender;\n        emit Bid(msg.sender, msg.value);\n    }\n\n    // 取回自己的出价\n    function withdraw() external {\n        uint256 bal = bids[msg.sender];\n        require(bal > 0, "No amount can be refunded");\n        bids[msg.sender] = 0; //为了防止漏洞发生，需要先把状态修改\n        payable(msg.sender).transfer(bal);\n        emit Withdraw(msg.sender, bal);\n    }\n\n    // 结束拍卖;不需要做身份确认，因为需要做的事情是固定的，\n    // 能不做身份判断就不需要做，可以节省Gas\n    function end() external {\n        require(started, "Not started"); // 需要已经开始\n        require(!ended, "is ended"); // 需要还没有结束\n        require(block.timestamp >= endAt, "auction in progress");\n        ended = true;\n\n        if (highestBider != address(0)) {\n            // 如果有人出价则将 NFT 给最高出价人，最高价格给销售者\n            nft.transferFrom(address(this), highestBider, nftId);\n            seller.transfer(highestBid);\n        } else {\n            // 如果没有人出价，则NFT原路返还给销售者\n            nft.transferFrom(address(this), seller, nftId);\n        }\n        emit End(highestBider, highestBid);\n    }\n\n    /*\n     * ========================================\n     * Helper\n     * ========================================\n     */\n    function getBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n}\n')])])]),n("h3",{attrs:{id:"测试流程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#测试流程"}},[e._v("#")]),e._v(" 测试流程")]),e._v(" "),n("ul",[n("li",[e._v("部署 ERC721 ,NFT 合约地址是 "),n("code",[e._v("nftContractAds")])]),e._v(" "),n("li",[e._v("给 "),n("code",[e._v("address1")]),e._v(" min 一个 ID 是 1 的 NFT")]),e._v(" "),n("li",[e._v("部署英式拍卖合约 "),n("code",[e._v("EnglishAuction")]),e._v(" "),n("ul",[n("li",[e._v("输入 NFT 合约地址")]),e._v(" "),n("li",[e._v("输入 NFT ID 号")]),e._v(" "),n("li",[e._v("起拍价格:8")])])]),e._v(" "),n("li",[e._v("在 "),n("code",[e._v("nftContractAds")]),e._v(" 中 approve "),n("code",[e._v("EnglishAuction")]),e._v(" , ID 为 1 的 NFT")]),e._v(" "),n("li",[e._v("使用 "),n("code",[e._v("address2")]),e._v(" 出价 1,查看是否返回错误 "),n("code",[e._v("Not started")])]),e._v(" "),n("li",[e._v("查看合约的状态\n"),n("ul",[n("li",[n("code",[e._v("started")])]),e._v(" "),n("li",[n("code",[e._v("ended")])]),e._v(" "),n("li",[n("code",[e._v("getBalance")])]),e._v(" "),n("li",[n("code",[e._v("seller")])]),e._v(" "),n("li",[n("code",[e._v("nft")])]),e._v(" "),n("li",[n("code",[e._v("nftId")])]),e._v(" "),n("li",[n("code",[e._v("highestBider")])]),e._v(" "),n("li",[n("code",[e._v("highestBid")])])])]),e._v(" "),n("li",[e._v("使用 "),n("code",[e._v("address1")]),e._v(" 出价 1, 开始拍卖合约，查看是否返回错误 "),n("code",[e._v("invalid price")])]),e._v(" "),n("li",[e._v("再次查看合约的状态")]),e._v(" "),n("li",[e._v("使用 "),n("code",[e._v("address2")]),e._v(" 出价 10")]),e._v(" "),n("li",[e._v("使用 "),n("code",[e._v("address3")]),e._v(" 出价 20")]),e._v(" "),n("li",[e._v("使用 "),n("code",[e._v("address2")]),e._v(" 出价 50")]),e._v(" "),n("li",[e._v("查询 "),n("code",[e._v("address2")]),e._v(" 可退换的主币")]),e._v(" "),n("li",[e._v("查询 "),n("code",[e._v("address3")]),e._v(" 可退换的主币")]),e._v(" "),n("li",[e._v("结束拍卖")]),e._v(" "),n("li",[e._v("使用 "),n("code",[e._v("address2")]),e._v(" 取回主币")]),e._v(" "),n("li",[e._v("使用 "),n("code",[e._v("address3")]),e._v(" 取回主币")])]),e._v(" "),n("h2",{attrs:{id:"️⃣-问答题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#️⃣-问答题"}},[e._v("#")]),e._v(" #️⃣ 问答题")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("interface")]),e._v(" 有哪些限制？\n"),n("ul",[n("li",[e._v("无法实现任何功能，没有函数体。\n"),n("ul",[n("li",[e._v("否则报错:"),n("code",[e._v("Functions in interfaces must be declared external.")])])])]),e._v(" "),n("li",[e._v("无法继承其他合约。(需要验证，是否可以继承接口，文档内说可以继承其他接口。)")]),e._v(" "),n("li",[e._v("无法定义构造函数。")]),e._v(" "),n("li",[e._v("无法定义状态变量。")]),e._v(" "),n("li",[e._v("不可以声明修改器。")]),e._v(" "),n("li",[e._v("无法定义结构（"),n("code",[e._v("strct")]),e._v("）（"),n("code",[e._v("0.5.0")]),e._v(" 版本开始接口里可以支持声明 "),n("code",[e._v("enum")]),e._v(" 类型）。")]),e._v(" "),n("li",[e._v("所有声明的函数必须是 "),n("code",[e._v("external")]),e._v(" 的，尽管在合约里可以是 public")]),e._v(" "),n("li",[e._v("文档说：将来可能会解除这里的某些限制。")])])]),e._v(" "),n("li",[n("code",[e._v("interface")]),e._v(" 的意义？\n"),n("ul",[n("li",[e._v("我们需要调用已经部署在链上的已经合约，这时候可以通过接口合约实现部分调用的逻辑，我们只需要写一个与之对应的接口合约，就可以调用了。")])])]),e._v(" "),n("li",[n("code",[e._v("interface")]),e._v(" 和 "),n("code",[e._v("abstract")]),e._v("(抽象合约)有啥区别？分别用在什么地方？")]),e._v(" "),n("li",[n("code",[e._v("interface")]),e._v(" 的常见用法有哪些？\n"),n("ul",[n("li",[e._v("制定标准，比如最成功的 "),n("code",[e._v("ERC20")]),e._v(" 接口合约")])])]),e._v(" "),n("li",[n("code",[e._v("ERC20")]),e._v(" 标准接口有哪些内容？\n"),n("ul",[n("li",[e._v("1 个授权（approve）")]),e._v(" "),n("li",[e._v("2 个事件（Transfer/Approval）")]),e._v(" "),n("li",[e._v("2 个交易（transfer/transferFrom）")]),e._v(" "),n("li",[e._v("3 个查询（totalSupply/balanceOf/allowance）")]),e._v(" "),n("li",[e._v("只要满足以上接口的都是 ERC20 标准合约，很多土狗合约喜欢在 transfer 内魔改。")])])]),e._v(" "),n("li",[e._v("全局属性 "),n("code",[e._v("type(I).interfaceId")]),e._v(" 使用？\n"),n("ul",[n("li",[e._v("没啥用，就是类似函数签名一样的十六进制数据，知道有这个属性就好。")])])]),e._v(" "),n("li",[e._v("聊一聊 "),n("code",[e._v("interface")]),e._v(" "),n("ul",[n("li",[e._v("就像继承其他合约一样，合约可以继承接口。接口中的函数都会隐式的标记为\n"),n("code",[e._v("virtual")]),e._v(" ，意味着他们会被重写并不需要 "),n("code",[e._v("override")]),e._v(" 关键字。\n但是不表示重写（overriding）函数可以再次重写，仅仅当重写的函数标记为\n"),n("code",[e._v("virtual")]),e._v(" 才可以再次重写。")])])])])])}),[],!1,null,null,null);n.default=a.exports}}]);