(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{437:function(t,e,s){"use strict";s.r(e);var a=s(2),v=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_05-运算操作符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_05-运算操作符"}},[t._v("#")]),t._v(" 05.运算操作符")]),t._v(" "),e("ul",[e("li",[t._v("算术运算符")]),t._v(" "),e("li",[t._v("比较运算符")]),t._v(" "),e("li",[t._v("逻辑运算符/关系运算符")]),t._v(" "),e("li",[t._v("赋值运算符")]),t._v(" "),e("li",[t._v("条件运算符/三元运算符")]),t._v(" "),e("li",[t._v("位运算符")]),t._v(" "),e("li",[t._v("delete")]),t._v(" "),e("li",[t._v("unchecked")]),t._v(" "),e("li",[e("strong",[t._v("两个类型不一样的操作数，也可以进行算术和位操作运算")]),t._v("。\n"),e("ul",[e("li",[t._v("例如，你可以计算 y = x + z ，其中 x 是 "),e("code",[t._v("uint8")]),t._v(" ， z 是 "),e("code",[t._v("int32")]),t._v(" 类型。 在这些情况下，将使用以下机制来确定运算结果的类型（这在溢出的情况下很重要）。")]),t._v(" "),e("li",[t._v("如果右操作数的类型可以隐含地转换为左操作数的类型的类型，则使用左操作数的类型。")]),t._v(" "),e("li",[t._v("如果左操作数的类型可以隐含地转换为右操作数的类型的类型，则使用右操作数的类型。")]),t._v(" "),e("li",[t._v("否则，该操作不被允许。")])])])]),t._v(" "),e("p",[t._v("如果其中一个操作数是一个常量数字，会首先被转换为能容纳该值的最小的类型 (相同位数时，无符号类型被认为比有符号类型 “小”)。 如果两者都是常量数字，则以任意的精度进行计算。")]),t._v(" "),e("p",[t._v("操作符的结果类型与执行操作的类型相同，除了比较运算符，其结果总是 "),e("code",[t._v("bool")]),t._v("。")]),t._v(" "),e("p",[t._v("运算符 "),e("code",[t._v("**")]),t._v("（幂）， "),e("code",[t._v("<<")]),t._v(" 和 "),e("code",[t._v(">>")]),t._v(" 使用左边操作数的类型来作为运算结果类型。")]),t._v(" "),e("h2",{attrs:{id:"_1️⃣-算术运算符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1️⃣-算术运算符"}},[t._v("#")]),t._v(" 1️⃣ 算术运算符")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("+")]),t._v("，"),e("code",[t._v("-")]),t._v("，"),e("code",[t._v("*")]),t._v("，"),e("code",[t._v("/")]),t._v("，"),e("code",[t._v("%")]),t._v("(取余,取模)，")]),t._v(" "),e("li",[e("code",[t._v("++")]),t._v("(递增),"),e("code",[t._v("--")]),t._v("(递减),"),e("code",[t._v("+=")]),t._v("(加法赋值),"),e("code",[t._v("-=")]),t._v("(减法赋值)")]),t._v(" "),e("li",[e("code",[t._v("**")]),t._v("（次方）")])]),t._v(" "),e("p",[t._v("不废话，直接上代码；")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Test {\n    uint256 public a = 5;\n    uint256 public b = 2;\n    uint256 public c1 = a + b;\n    uint256 public c2 = a - b;\n    uint256 public c3 = a * b;\n    uint256 public c4 = a / b;\n    uint256 public c5 = a % b;\n\n    // uint256 public c6 = a++; // 会影响a的值\n\n    function increment1() public view returns (uint256) {\n        uint256 temp = a;\n        return temp++;\n    }\n\n    function increment2() public view returns (uint256) {\n        uint256 temp = a;\n        return ++temp;\n    }\n\n    function reduce1() public view returns (uint256) {\n        uint256 temp = a;\n        return temp--;\n    }\n\n    function reduce2() public view returns (uint256) {\n        uint256 temp = a;\n        return --temp;\n    }\n\n    function plusAssign() public view returns (uint256) {\n        uint256 temp = a;\n        return temp += 2;\n    }\n\n    function minusAssign() public view returns (uint256) {\n        uint256 temp = a;\n        return temp -= 2;\n    }\n\n    function test1() public view returns (uint256) {\n        return b**3;\n    }\n}\n")])])]),e("h3",{attrs:{id:"unchecked"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#unchecked"}},[t._v("#")]),t._v(" unchecked")]),t._v(" "),e("p",[t._v("默认情况下，算术运算都会进行溢出检查，但是也可以禁用检查，可以通过 "),e("code",[t._v("unchecked block")]),t._v(" 来禁用检查，此时会返回截断的结果。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function f(uint a, uint b) pure public returns (uint) {\n    // 减法溢出会返回“截断”的结果\n    unchecked { return a - b; }\n}\n")])])]),e("p",[t._v("溢出的检查功能是在 "),e("code",[t._v("0.8.0")]),t._v(" 版本加入的，在此版本之前，请使用 "),e("strong",[t._v("OpenZepplin SafeMath")]),t._v(" 库。")]),t._v(" "),e("h3",{attrs:{id:"一元运算负"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一元运算负"}},[t._v("#")]),t._v(" 一元运算负 "),e("code",[t._v("-")])]),t._v(" "),e("p",[t._v("表达式 "),e("code",[t._v("-x")]),t._v(" 相当于 "),e("code",[t._v("(T(0) - x)")]),t._v(" 这里 "),e("code",[t._v("T")]),t._v(" 是指 "),e("code",[t._v("x")]),t._v(" 的类型。 "),e("code",[t._v("-x")]),t._v(" 只能应用在有符号型的整数上。 如果 "),e("code",[t._v("x")]),t._v(" 为负数， "),e("code",[t._v("-x")]),t._v(" 为正数。")]),t._v(" "),e("p",[t._v("由于使用两进制补码表示数据，你还需要小心:如果有 "),e("code",[t._v("int x = type(int).min;")]),t._v("， 那 "),e("code",[t._v("-x")]),t._v(" 将不在正数取值的范围内。 这意味着这个检测 "),e("code",[t._v("unchecked { assert(-x == x); }")]),t._v(" 是可以通过的（即这种情况下，不能假设它的负数会是正数），如果是 checked 模式，则会触发异常。")]),t._v(" "),e("h3",{attrs:{id:"除法运算"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#除法运算"}},[t._v("#")]),t._v(" 除法运算")]),t._v(" "),e("p",[t._v("除法运算结果的类型始终是其中一个操作数的类型，整数除法总是产生整数。在 Solidity 中，分数会取零。 这意味着 "),e("code",[t._v("int256(-5) / int256(2) == int256(-2)")]),t._v(" 。")]),t._v(" "),e("h3",{attrs:{id:"模运算-取余"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模运算-取余"}},[t._v("#")]),t._v(" 模运算（取余）")]),t._v(" "),e("p",[t._v("模运算 "),e("code",[t._v("a％n")]),t._v(" 是在操作数 "),e("code",[t._v("a")]),t._v(" 的除以 "),e("code",[t._v("n")]),t._v(" 之后产生余数 "),e("code",[t._v("r")]),t._v(" ，其中 "),e("code",[t._v("q = int(a / n)")]),t._v(" 和 "),e("code",[t._v("r = a - (n * q)")]),t._v(" 。 这意味着模运算结果与左操作数相同的符号相同（或零）。 对于 负数的 a : "),e("code",[t._v("a % n == -(-a % n)")]),t._v("， 几个例子：")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("int256(5) % int256(2) == int256(1)")])]),t._v(" "),e("li",[e("code",[t._v("int256(5) % int256(-2) == int256(1)")])]),t._v(" "),e("li",[e("code",[t._v("int256(-5) % int256(2) == int256(-1)")])]),t._v(" "),e("li",[e("code",[t._v("int256(-5) % int256(-2) == int256(-1)")])])]),t._v(" "),e("p",[t._v("对 0 取模会发生错误 "),e("code",[t._v("Panic")]),t._v(" 错误，该检查不能通过"),e("code",[t._v("unchecked { … }")]),t._v(" 。")]),t._v(" "),e("h3",{attrs:{id:"幂运算"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#幂运算"}},[t._v("#")]),t._v(" 幂运算")]),t._v(" "),e("p",[t._v("幂运算仅适用于无符号类型。 结果的类型总是等于基数的类型. 请注意类型足够大以能够容纳幂运算的结果，要么发生潜在的 assert 异常或者使用截断模式。")]),t._v(" "),e("p",[t._v("在 "),e("code",[t._v("checked")]),t._v(" 模式下，幂运算仅会为小基数使用相对便宜的 "),e("code",[t._v("exp")]),t._v(" 操作码。 例如 "),e("code",[t._v("x**3")]),t._v(" 的例子，表达式 "),e("code",[t._v("x*x*x")]),t._v(" 也许更便宜。 在任何情况下，都建议进行 "),e("code",[t._v("gas")]),t._v(" 消耗测试和使用优化器。")]),t._v(" "),e("p",[t._v("扩展 TODO: 可以自己测试多少为临界值")]),t._v(" "),e("p",[t._v("注意 "),e("code",[t._v("0**0")]),t._v(" 在 EVM 中定义为 1 。")]),t._v(" "),e("h3",{attrs:{id:"i-和-i-区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#i-和-i-区别"}},[t._v("#")]),t._v(" i++ 和 ++i 区别")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("a = i++")]),t._v(": 先把 i 的值赋予 a，然后在执行 i=i+1；")]),t._v(" "),e("li",[e("code",[t._v("a = ++i")]),t._v(": 先执行 i=i+1，然后在把 i 的值赋予 a；")])]),t._v(" "),e("h4",{attrs:{id:"for-循环中-i-更省钱"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#for-循环中-i-更省钱"}},[t._v("#")]),t._v(" for 循环中，++i 更省钱")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Test {\n    // 25153 gas\n    function test1() public pure returns (uint256 temp) {\n        for (uint256 index = 0; index < 10; index++) {\n            temp += index;\n        }\n    }\n\n    // 25081 gas\n    function test2() public pure returns (uint256 temp) {\n        for (uint256 index = 0; index < 10; ++index) {\n            temp += index;\n        }\n    }\n}\n")])])]),e("h3",{attrs:{id:"赋值运算符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#赋值运算符"}},[t._v("#")]),t._v(" 赋值运算符")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("=")]),t._v("(简单赋值)")]),t._v(" "),e("li",[e("code",[t._v("+=")]),t._v(" (相加赋值)")]),t._v(" "),e("li",[e("code",[t._v("−=")]),t._v(" (相减赋值)")]),t._v(" "),e("li",[e("code",[t._v("*=")]),t._v(" (相乘赋值)")]),t._v(" "),e("li",[e("code",[t._v("/=")]),t._v(" (相除赋值)")]),t._v(" "),e("li",[e("code",[t._v("%=")]),t._v(" (取模赋值)")])]),t._v(" "),e("p",[t._v("注意： 同样的逻辑也适用于位运算符，因此它们将变成 "),e("code",[t._v("<<=")]),t._v("、"),e("code",[t._v(">>=")]),t._v("、"),e("code",[t._v(">>=")]),t._v("、"),e("code",[t._v("&=")]),t._v("、"),e("code",[t._v("|=")]),t._v("和"),e("code",[t._v("^=")]),t._v("。")]),t._v(" "),e("p",[t._v("不废话，直接上代码；")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Test {\n    uint256 public a = 20;\n    uint256 public b = 10;\n\n    function test1() public view returns (uint256 temp) {\n        temp = a + b;\n    }\n\n    function test2() public view returns (uint256 temp) {\n        temp = a;\n        temp += b;\n    }\n\n    function test3() public view returns (uint256 temp) {\n        temp = a;\n        temp -= b;\n    }\n\n    function test4() public view returns (uint256 temp) {\n        temp = a;\n        temp *= b;\n    }\n\n    function test5() public view returns (uint256 temp) {\n        temp = a;\n        temp /= b;\n    }\n\n    function test6() public view returns (uint256 temp) {\n        temp = a;\n        temp %= b;\n    }\n}\n")])])]),e("p",[e("code",[t._v("a += e")]),t._v(" 等同于 "),e("code",[t._v("a = a + e")]),t._v("。其它运算符如 "),e("code",[t._v("-=")]),t._v("， "),e("code",[t._v("*=")]),t._v("， "),e("code",[t._v("/=")]),t._v("， "),e("code",[t._v("%=")]),t._v("， "),e("code",[t._v("|=")]),t._v("， "),e("code",[t._v("&=")]),t._v(" ， "),e("code",[t._v("^=")]),t._v(" ， "),e("code",[t._v("<<=")]),t._v(" 和 "),e("code",[t._v(">>=")]),t._v(" 都是如此定义的。")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("a++")]),t._v(" 和 "),e("code",[t._v("a--")]),t._v(" 分别等同于 "),e("code",[t._v("a += 1")]),t._v(" 和 "),e("code",[t._v("a -= 1")]),t._v("，但表达式本身的值等于 "),e("code",[t._v("a")]),t._v(" 在计算之前的值。")]),t._v(" "),e("li",[t._v("与之相反， "),e("code",[t._v("--a")]),t._v(" 和 "),e("code",[t._v("++a")]),t._v(" 虽然最终 "),e("code",[t._v("a")]),t._v(" 的结果与之前的表达式相同，但表达式的返回值是计算之后的值。")])]),t._v(" "),e("h2",{attrs:{id:"_2️⃣-关系运算符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2️⃣-关系运算符"}},[t._v("#")]),t._v(" 2️⃣ 关系运算符")]),t._v(" "),e("p",[t._v("关系运算符一共有六种：分别为： 大于 、小于 、 大于等于 、 小于等于 、 等于 和 不等于 。")]),t._v(" "),e("ul",[e("li",[e("code",[t._v(">")]),t._v(" (大于)")]),t._v(" "),e("li",[e("code",[t._v("<")]),t._v(" (小于)")]),t._v(" "),e("li",[e("code",[t._v(">=")]),t._v(" (大于等于)")]),t._v(" "),e("li",[e("code",[t._v("<=")]),t._v(" (小于等于)")]),t._v(" "),e("li",[e("code",[t._v("==")]),t._v(" (等于)")]),t._v(" "),e("li",[e("code",[t._v("!=")]),t._v(" (不等于)")])]),t._v(" "),e("p",[e("strong",[t._v("返回的结果是一个布尔值；")])]),t._v(" "),e("p",[t._v("直接上代码；")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Test {\n    uint256 public a = 20;\n    uint256 public b = 10;\n\n    function test1() public view returns (bool) {\n        return a == b;\n    }\n\n    function test2() public view returns (bool) {\n        return a != b;\n    }\n\n    function test3() public view returns (bool) {\n        return a > b;\n    }\n\n    function test4() public view returns (bool) {\n        return a >= b;\n    }\n\n    function test5() public view returns (bool) {\n        return a < b;\n    }\n\n    function test6() public view returns (bool) {\n        return a <= b;\n    }\n}\n")])])]),e("h3",{attrs:{id:"布尔类型-支持的运算符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#布尔类型-支持的运算符"}},[t._v("#")]),t._v(" 布尔类型 支持的运算符")]),t._v(" "),e("ul",[e("li",[t._v("包括："),e("code",[t._v("!")]),t._v("逻辑非")]),t._v(" "),e("li",[e("code",[t._v("==")]),t._v("等于，"),e("code",[t._v("!=")]),t._v(" 不等于")]),t._v(" "),e("li",[e("code",[t._v("&&")]),t._v("逻辑与，"),e("code",[t._v("||")]),t._v("逻辑或\n"),e("ul",[e("li",[e("code",[t._v("&&")]),t._v("，"),e("code",[t._v("||")]),t._v(" 为短路运算符")])])])]),t._v(" "),e("h3",{attrs:{id:"地址类型-支持的运算符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#地址类型-支持的运算符"}},[t._v("#")]),t._v(" 地址类型 支持的运算符")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("<=")]),t._v(", "),e("code",[t._v("<")]),t._v(", "),e("code",[t._v("==")]),t._v(", "),e("code",[t._v("!=")]),t._v(", "),e("code",[t._v(">=")]),t._v(" and "),e("code",[t._v(">")])])]),t._v(" "),e("h4",{attrs:{id:"和"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#和"}},[t._v("#")]),t._v(" "),e("code",[t._v("==")]),t._v(" 和 "),e("code",[t._v("!=")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Demo {\n    address public immutable owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function isOwner() external view returns (bool) {\n        return owner == msg.sender;\n    }\n\n    function test1(address _ads) external pure returns (bool) {\n        return address(0) != _ads;\n    }\n}\n")])])]),e("h4",{attrs:{id:""}},[e("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")]),t._v(" "),e("code",[t._v(">")]),t._v(" "),e("code",[t._v(">=")]),t._v(" "),e("code",[t._v("<")]),t._v(" "),e("code",[t._v("<=")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Demo {\n    function test1(address _ads) external pure returns (bool) {\n        return _ads > address(9);\n    }\n\n    function test2(address _ads) external pure returns (bool) {\n        return _ads >= address(9);\n    }\n\n    function test3(address _ads) external pure returns (bool) {\n        return _ads < address(9);\n    }\n\n    function test4(address _ads) external pure returns (bool) {\n        return _ads <= address(9);\n    }\n}\n")])])]),e("h4",{attrs:{id:"交换地址"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#交换地址"}},[t._v("#")]),t._v(" 交换地址")]),t._v(" "),e("p",[t._v("Uniswap V2 中 createPair 时的判断逻辑：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("(address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\nrequire(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');\nrequire(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // single check is sufficient\n")])])]),e("h3",{attrs:{id:"定长字节数组-支持的运算符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定长字节数组-支持的运算符"}},[t._v("#")]),t._v(" 定长字节数组 支持的运算符")]),t._v(" "),e("ul",[e("li",[t._v("比较运算符： "),e("code",[t._v("<=")]),t._v("， "),e("code",[t._v("<")]),t._v("， "),e("code",[t._v("==")]),t._v("， "),e("code",[t._v("!=")]),t._v("， "),e("code",[t._v(">=")]),t._v("， "),e("code",[t._v(">")]),t._v(" （返回布尔型）")]),t._v(" "),e("li",[t._v("位运算符： "),e("code",[t._v("&")]),t._v("， "),e("code",[t._v("|")]),t._v("， "),e("code",[t._v("^")]),t._v(" （按位异或）， "),e("code",[t._v("~")]),t._v(" （按位取反）")]),t._v(" "),e("li",[t._v("移位运算符： "),e("code",[t._v("<<")]),t._v(" （左移位）， "),e("code",[t._v(">>")]),t._v(" （右移位）")]),t._v(" "),e("li",[t._v("索引访问：如果 "),e("code",[t._v("x")]),t._v(" 是 "),e("code",[t._v("bytesI")]),t._v(" 类型，那么 "),e("code",[t._v("x[k]")]),t._v(" （其中 0 <= k < I）返回第 k 个字节（只读）。")])]),t._v(" "),e("p",[t._v("该类型可以和作为右操作数的无符号整数类型进行移位运算（但返回结果的类型和左操作数类型相同），右操作数表示需要移动的位数。 进行有符号整数位移运算会引发运行时异常。")]),t._v(" "),e("h2",{attrs:{id:"_3️⃣-逻辑运算符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3️⃣-逻辑运算符"}},[t._v("#")]),t._v(" 3️⃣ 逻辑运算符")]),t._v(" "),e("h3",{attrs:{id:"_1-基础用法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-基础用法"}},[t._v("#")]),t._v(" 1. 基础用法")]),t._v(" "),e("ul",[e("li",[t._v("&& (逻辑与)\n"),e("ul",[e("li",[t._v("如果两个操作数都是 true ，则条件为真。")])])]),t._v(" "),e("li",[t._v("|| (逻辑或)\n"),e("ul",[e("li",[t._v("如果两个操作数有一个为 true ，则条件为真。")])])]),t._v(" "),e("li",[t._v("! (逻辑非)\n"),e("ul",[e("li",[t._v("反转操作数的逻辑状态。如果条件为真，则逻辑非操作将使其为假。")])])])]),t._v(" "),e("p",[t._v("不废话，直接上代码；")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Test {\n    uint256 public a = 20;\n    uint256 public b = 10;\n\n    function test1() public view returns (bool) {\n        bool assertion1 = a > 15;\n        bool assertion2 = b > 15;\n        return assertion1 && assertion2;\n    }\n\n    function test2() public view returns (bool) {\n        bool assertion1 = a > 15;\n        bool assertion2 = b > 15;\n        return assertion1 || assertion2;\n    }\n\n    function test3() public view returns (bool assertion1, bool assertion2) {\n        assertion1 = a > 15;\n        assertion2 = !(b > 15);\n    }\n}\n")])])]),e("h3",{attrs:{id:"_2-和-的短路用法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-和-的短路用法"}},[t._v("#")]),t._v(" 2. "),e("code",[t._v("&&")]),t._v(" 和 "),e("code",[t._v("||")]),t._v(" 的短路用法")]),t._v(" "),e("p",[t._v("原理:")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("A && B")]),t._v(",如果 A 为 false，B 就不执行了")]),t._v(" "),e("li",[e("code",[t._v("A || B")]),t._v(",如果 A 为 true，B 就不执行了")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Test {\n    uint256 public a = 10;\n    uint256 public b = 20;\n\n    event Assertion1(string msg);\n    event Assertion2(string msg);\n\n    // 29319 gas\n    function test1() public returns (bool) {\n        return assertion1() || assertion2();\n    }\n\n    // 29365 gas\n    function testA() public returns (bool) {\n        bool as1 = assertion1();\n        bool as2 = assertion2();\n        return as1 && as2;\n    }\n\n    // 25430 gas\n    // 因为短路操作，减少了很多 gas\n    function testB() public returns (bool) {\n        return assertion1() && assertion2();\n    }\n\n    function assertion1() private returns (bool) {\n        emit Assertion1("Assertion1 run");\n        return a > 15;\n    }\n\n    function assertion2() private returns (bool) {\n        emit Assertion2("Assertion1 run");\n        return b > 15;\n    }\n}\n')])])]),e("p",[t._v("合理的使用短路操作，可以省一些 gas 费。")]),t._v(" "),e("h2",{attrs:{id:"_4️⃣-三元运算符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4️⃣-三元运算符"}},[t._v("#")]),t._v(" 4️⃣ 三元运算符")]),t._v(" "),e("p",[t._v("三元运算符是一个表达是形式： "),e("code",[t._v("<expression> ? <trueExpression> : <falseExpression>")]),t._v(" 。 它根据 "),e("code",[t._v("<expression>")]),t._v(" 的执行结果，选择后两个给定表达式中的一个。 如果 "),e("code",[t._v("<expression>")]),t._v(" 执行结果 true ，那么 "),e("code",[t._v("<trueExpression>")]),t._v(" 将被执行，否则 "),e("code",[t._v("<falseExpression>")]),t._v(" 被执行。")]),t._v(" "),e("p",[t._v("代码如下:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Test {\n    uint256 public a = 20;\n    uint256 public b = 10;\n\n    function test1() public view returns (bool) {\n        uint256 temp = a + b;\n        return temp > 25 ? true : false;\n    }\n\n    function test2() public view returns (bool) {\n        uint256 temp = a + b;\n        return temp < 25 ? true : false;\n    }\n}\n")])])]),e("p",[t._v("三元运算符的结果类型是由两个操作数的类型决定的，方法与上面一样，如果需要的话，首先转换为它们的最小可容纳类型（mobile type ）。")]),t._v(" "),e("p",[t._v("因此， "),e("code",[t._v("255 + (true ? 1 : 0)")]),t._v(" 将由于算术溢出而被回退。 原因是 "),e("code",[t._v("(true ? 1 : 0)")]),t._v(" 是 uint8 类型，这迫使加法也要在 "),e("code",[t._v("uint8")]),t._v(" 中执行。 而 "),e("code",[t._v("256")]),t._v(" 超出了这个类型所允许的范围。")]),t._v(" "),e("p",[t._v("另一个结果是，像 "),e("code",[t._v("1.5 + 1.5")]),t._v(" 这样的表达式是有效的，但 "),e("code",[t._v("1.5 + (true ? 1.5 : 2.5)")]),t._v(" 则无效。 这是因为前者是以无限精度来进行有理表达式运算，只有它的最终结果值才是重要的。 后者涉及到将小数有理数转换为整数，这在目前是不允许的。")]),t._v(" "),e("h2",{attrs:{id:"_5️⃣-位运算符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5️⃣-位运算符"}},[t._v("#")]),t._v(" 5️⃣ 位运算符")]),t._v(" "),e("p",[t._v("位运算在数字的二进制补码表示上执行。 这意味着： "),e("code",[t._v("~int256(0)== int256(-1)")]),t._v("。")]),t._v(" "),e("p",[t._v("假设 A 等于 2；B 等于 3。")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("&")]),t._v(" (位与): 对其整数参数的每个位执行位与操作。\n"),e("ul",[e("li",[t._v("例: (A & B) 为 2.")])])]),t._v(" "),e("li",[e("code",[t._v("|")]),t._v(" (位或): 对其整数参数的每个位执行位或操作。\n"),e("ul",[e("li",[t._v("例: (A | B) 为 3.")])])]),t._v(" "),e("li",[e("code",[t._v("^")]),t._v(" (位异或): 对其整数参数的每个位执行位异或操作。\n"),e("ul",[e("li",[t._v("例: (A ^ B) 为 1.")])])]),t._v(" "),e("li",[e("code",[t._v("~")]),t._v(" (位非): 一元操作符，反转操作数中的所有位。\n"),e("ul",[e("li",[t._v("例: (~B) 为 -4.")])])]),t._v(" "),e("li",[e("code",[t._v("<<")]),t._v(" (左移位)): 将第一个操作数中的所有位向左移动，移动的位置数由第二个操作数指定，新的位由 0 填充。将一个值向左移动一个位置相当于乘以 2，移动两个位置相当于乘以 4，以此类推。\n"),e("ul",[e("li",[t._v("例: (A << 1) 为 4.")])])]),t._v(" "),e("li",[e("code",[t._v(">>")]),t._v(" (右移位): 左操作数的值向右移动，移动位置数量由右操作数指定\n"),e("ul",[e("li",[t._v("例: (A >> 1) 为 1.")])])])]),t._v(" "),e("p",[t._v("如果两个中的任一个数是小数，则不允许进行位运算。如果指数是小数的话，也不支持幂运算（因为这样可能会得到一个无理数）。")]),t._v(" "),e("p",[t._v("数学运算:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Test {\n    uint256 public a = 5;\n    uint256 public b = 2;\n\n    // 左移操作符将第一个操作数向左移动指定位数，左边超出的位数将会被清除，右边将会补零。\n    function test2() public view returns (uint256) {\n        // a: ...000000000101\n        // b: ...000000000010\n        // ------------------\n        // =: 00...000000010100\n        // =: ...000000010100\n        return a << b;\n    }\n\n    // 右移操作符 (>>) 是将一个操作数按指定移动的位数向右移动，右边移出位被丢弃，左边移出的空位补符号位。\n    function test3() public view returns (uint256) {\n        // a: ...000000000101\n        // b: ...000000000010\n        // ------------------\n        // =: ...00000000000101\n        // =: ...000000000001\n        return a >> b;\n    }\n}\n")])])]),e("p",[t._v("移位操作的结果具有左操作数的类型，同时会截断结果以匹配类型。 右操作数必须是无符号类型。尝试按带符号的类型移动将产生编译错误。"),e("strong",[t._v("对于移位操作不会像算术运算那样执行溢出检查，其结果总是被截断。")])]),t._v(" "),e("p",[t._v("移位可以通过用 2 的幂的乘法来 “模拟”(方法如下)。请注意，左操作数的截断总是在最后发生。")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("x << y")]),t._v(" 等于数学表达式 "),e("code",[t._v("x * 2 ** y")]),t._v("。\n"),e("ul",[e("li",[e("code",[t._v("5 << 2")]),t._v(" = "),e("code",[t._v("5*2**2")]),t._v(" = 20")])])]),t._v(" "),e("li",[e("code",[t._v("x >> y")]),t._v(" 等于数学表达式 "),e("code",[t._v("x / 2 ** y")]),t._v(" ， 四舍五入到负无穷。\n"),e("ul",[e("li",[e("code",[t._v("5 >> 2")]),t._v(" = "),e("code",[t._v("5/2**2")]),t._v(" = 1")])])])]),t._v(" "),e("h2",{attrs:{id:"_6️⃣-delete"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6️⃣-delete"}},[t._v("#")]),t._v(" 6️⃣ delete")]),t._v(" "),e("p",[e("code",[t._v("delete a")]),t._v(" 的结果是将 "),e("code",[t._v("a")]),t._v(" 类型初始值赋值给"),e("code",[t._v("a")]),t._v("。换句话说，在 "),e("code",[t._v("delete a")]),t._v(" 之后 "),e("code",[t._v("a")]),t._v(" 的值与在没有赋值的情况下声明 "),e("code",[t._v("a")]),t._v(" 的情况相同。")]),t._v(" "),e("p",[e("code",[t._v("delete")]),t._v(" 适用于整型，数组，结构体映射。")]),t._v(" "),e("ul",[e("li",[t._v("对于整型变量：相当于 "),e("code",[t._v("a = 0")]),t._v("。")]),t._v(" "),e("li",[t._v("对于动态数组：是将重置为数组长度为 0 的数组")]),t._v(" "),e("li",[t._v("对于静态数组：是将数组中的所有元素重置为初始值。")]),t._v(" "),e("li",[t._v("对于数组而言："),e("code",[t._v("delete a[x]")]),t._v(" 仅删除数组索引 "),e("code",[t._v("x")]),t._v(" 处的元素，其他的元素和长度不变，这为数组留出了一个空位。如果打算删除项，映射可能是更好的选择。")]),t._v(" "),e("li",[t._v("对于结构体：则将结构体中的所有属性(成员)重置。")]),t._v(" "),e("li",[t._v("mapping : 是将所选择的 key 重置为初始值。")])]),t._v(" "),e("p",[t._v("代码如下:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Demo {\n    struct Book {\n        string title;\n        string author;\n        uint256 book_id;\n    }\n\n    // 整数\n    uint256 public a1 = 1;\n    int256 public a2 = -1;\n\n    // 数组\n    uint256[2] b1 = [1, 2]; // 定长\n    uint256[] b2 = [1, 2]; // 变长\n\n    // mapping\n    mapping(address => uint256) public balances;\n\n    // struct\n    Book public java; // 一本 java 书\n\n    constructor() {\n        java = Book({title: "Java", author: "LiSi", book_id: 1});\n        balances[msg.sender] = 999;\n    }\n\n    function deleteFn() public {\n        delete a1;\n        delete a2;\n        delete b1;\n        delete b2;\n        delete balances[msg.sender];\n        delete java;\n    }\n\n    function getB1() public view returns (uint256[2] memory) {\n        return b1;\n    }\n\n    function getB2() public view returns (uint256[] memory) {\n        return b2;\n    }\n}\n')])])]),e("p",[t._v("需要注意以下几点：")]),t._v(" "),e("p",[e("code",[t._v("delete")]),t._v(" 对整个映射是无效的（因为映射的键可以是任意的，通常也是未知的）。因此在你删除一个结构体时，结果将重置所有的非映射属性（成员），这个过程是递归进行的，除非它们是映射。然而，单个的键及其映射的值是可以被删除的。")]),t._v(" "),e("p",[t._v("理解 "),e("code",[t._v("delete a")]),t._v(" 的效果就像是给 "),e("code",[t._v("a")]),t._v(" 赋值很重要，换句话说，这相当于在 "),e("code",[t._v("a")]),t._v("中存储了一个新的对象。")]),t._v(" "),e("p",[t._v("当 "),e("code",[t._v("a")]),t._v(" 是应用变量时，我们可以看到这个区别， "),e("code",[t._v("delete a")]),t._v(" 它只会重置 "),e("code",[t._v("a")]),t._v(" 本身，而不是更改它之前引用的值。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract DeleteLBC {\n    uint256 data;\n    uint256[] dataArray;\n\n    function f() public {\n        uint256 x = data;\n        delete x; // 将 x 设为 0，并不影响数据\n        delete data; // 将 data 设为 0，并不影响 x，因为它仍然有个副本\n        uint256[] storage y = dataArray;\n        delete dataArray;\n        // 将 dataArray.length 设为 0，但由于 uint[] 是一个复杂的对象，y 也将受到影响，\n        // 因为它是一个存储位置是 storage 的对象的别名。\n        // 另一方面："delete y" 是非法的，引用了 storage 对象的局部变量只能由已有的 storage 对象赋值。\n        assert(y.length == 0);\n    }\n}\n')])])]),e("h2",{attrs:{id:"_7️⃣-操作符的优先级"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7️⃣-操作符的优先级"}},[t._v("#")]),t._v(" 7️⃣ 操作符的优先级")]),t._v(" "),e("table",{staticClass:"docutils",attrs:{border:"1"}},[e("colgroup",[e("col",{attrs:{width:"13%"}}),t._v(" "),e("col",{attrs:{width:"40%"}}),t._v(" "),e("col",{attrs:{width:"47%"}})]),t._v(" "),e("thead",{attrs:{valign:"bottom"}},[e("tr",{staticClass:"row-odd"},[e("th",{staticClass:"head"},[t._v("优先级")]),t._v(" "),e("th",{staticClass:"head"},[t._v("描述")]),t._v(" "),e("th",{staticClass:"head"},[t._v("操作符")])])]),t._v(" "),e("tbody",{attrs:{valign:"top"}},[e("tr",{staticClass:"row-even"},[e("td",{attrs:{rowspan:"6"}},[e("em",[t._v("1")])]),t._v(" "),e("td",[t._v("后置自增和自减")]),t._v(" "),e("td",[e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("++")])]),t._v(", "),e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("--")])])])]),t._v(" "),e("tr",{staticClass:"row-odd"},[e("td",[t._v("创建类型实例")]),t._v(" "),e("td",[e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("new")]),t._v(" "),e("span",{staticClass:"pre"},[t._v("<typename>")])])])]),t._v(" "),e("tr",{staticClass:"row-even"},[e("td",[t._v("数组元素")]),t._v(" "),e("td",[e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("<array>[<index>]")])])])]),t._v(" "),e("tr",{staticClass:"row-odd"},[e("td",[t._v("访问成员")]),t._v(" "),e("td",[e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("<object>.<member>")])])])]),t._v(" "),e("tr",{staticClass:"row-even"},[e("td",[t._v("函数调用")]),t._v(" "),e("td",[e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("<func>(<args...>)")])])])]),t._v(" "),e("tr",{staticClass:"row-odd"},[e("td",[t._v("小括号")]),t._v(" "),e("td",[e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("(<statement>)")])])])]),t._v(" "),e("tr",{staticClass:"row-even"},[e("td",{attrs:{rowspan:"5"}},[e("em",[t._v("2")])]),t._v(" "),e("td",[t._v("前置自增和自减")]),t._v(" "),e("td",[e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("++")])]),t._v(", "),e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("--")])])])]),t._v(" "),e("tr",{staticClass:"row-odd"},[e("td",[t._v("一元运算的加和减")]),t._v(" "),e("td",[e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("+")])]),t._v(", "),e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("-")])])])]),t._v(" "),e("tr",{staticClass:"row-even"},[e("td",[t._v("一元操作符")]),t._v(" "),e("td",[e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("delete")])])])]),t._v(" "),e("tr",{staticClass:"row-odd"},[e("td",[t._v("逻辑非")]),t._v(" "),e("td",[e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("!")])])])]),t._v(" "),e("tr",{staticClass:"row-even"},[e("td",[t._v("按位非")]),t._v(" "),e("td",[e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("~")])])])]),t._v(" "),e("tr",{staticClass:"row-odd"},[e("td",[e("em",[t._v("3")])]),t._v(" "),e("td",[t._v("乘方")]),t._v(" "),e("td",[e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[e("em",[t._v("*")])])])])]),t._v(" "),e("tr",{staticClass:"row-even"},[e("td",[e("em",[t._v("4")])]),t._v(" "),e("td",[t._v("乘、除和模运算")]),t._v(" "),e("td",[e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"})]),t._v(", "),e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("/")])]),t._v(", "),e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("%")])])])]),t._v(" "),e("tr",{staticClass:"row-odd"},[e("td",[e("em",[t._v("5")])]),t._v(" "),e("td",[t._v("算术加和减")]),t._v(" "),e("td",[e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("+")])]),t._v(", "),e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("-")])])])]),t._v(" "),e("tr",{staticClass:"row-even"},[e("td",[e("em",[t._v("6")])]),t._v(" "),e("td",[t._v("移位操作符")]),t._v(" "),e("td",[e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("<<")])]),t._v(", "),e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v(">>")])])])]),t._v(" "),e("tr",{staticClass:"row-odd"},[e("td",[e("em",[t._v("7")])]),t._v(" "),e("td",[t._v("按位与")]),t._v(" "),e("td",[e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("&")])])])]),t._v(" "),e("tr",{staticClass:"row-even"},[e("td",[e("em",[t._v("8")])]),t._v(" "),e("td",[t._v("按位异或")]),t._v(" "),e("td",[e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("^")])])])]),t._v(" "),e("tr",{staticClass:"row-odd"},[e("td",[e("em",[t._v("9")])]),t._v(" "),e("td",[t._v("按位或")]),t._v(" "),e("td",[e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("|")])])])]),t._v(" "),e("tr",{staticClass:"row-even"},[e("td",[e("em",[t._v("10")])]),t._v(" "),e("td",[t._v("非等操作符")]),t._v(" "),e("td",[e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("<")])]),t._v(", "),e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v(">")])]),t._v(", "),e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("<=")])]),t._v(", "),e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v(">=")])])])]),t._v(" "),e("tr",{staticClass:"row-odd"},[e("td",[e("em",[t._v("11")])]),t._v(" "),e("td",[t._v("等于操作符")]),t._v(" "),e("td",[e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("==")])]),t._v(", "),e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("!=")])])])]),t._v(" "),e("tr",{staticClass:"row-even"},[e("td",[e("em",[t._v("12")])]),t._v(" "),e("td",[t._v("逻辑与")]),t._v(" "),e("td",[e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("&&")])])])]),t._v(" "),e("tr",{staticClass:"row-odd"},[e("td",[e("em",[t._v("13")])]),t._v(" "),e("td",[t._v("逻辑或")]),t._v(" "),e("td",[e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("||")])])])]),t._v(" "),e("tr",{staticClass:"row-even"},[e("td",[e("em",[t._v("14")])]),t._v(" "),e("td",[t._v("三元操作符")]),t._v(" "),e("td",[e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("<conditional>")]),t._v(" "),e("span",{staticClass:"pre"},[t._v("?")]),t._v(" "),e("span",{staticClass:"pre"},[t._v("<if-true>")]),t._v(" "),e("span",{staticClass:"pre"},[t._v(":")]),t._v(" "),e("span",{staticClass:"pre"},[t._v("<if-false>")])])])]),t._v(" "),e("tr",{staticClass:"row-odd"},[e("td",[e("em",[t._v("15")])]),t._v(" "),e("td",[t._v("赋值操作符")]),t._v(" "),e("td",[e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("=")])]),t._v(", "),e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("|=")])]),t._v(", "),e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("^=")])]),t._v(", "),e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("&=")])]),t._v(", "),e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("<<=")])]),t._v(",\n"),e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v(">>=")])]),t._v(", "),e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("+=")])]),t._v(", "),e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("-=")])]),t._v(", "),e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("*=")])]),t._v(", "),e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("/=")])]),t._v(",\n"),e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v("%=")])])])]),t._v(" "),e("tr",{staticClass:"row-even"},[e("td",[e("em",[t._v("16")])]),t._v(" "),e("td",[t._v("逗号")]),t._v(" "),e("td",[e("code",{staticClass:"docutils literal notranslate"},[e("span",{staticClass:"pre"},[t._v(",")])])])])])]),t._v(" "),e("p",[t._v("表达式的计算顺序不是特定的（更准确地说，表达式树中某节点的字节点间的计算顺序不是特定的，但它们的结算肯定会在节点自己的结算之前）。该规则只能保证语句按顺序执行，布尔表达式的短路执行。")]),t._v(" "),e("h2",{attrs:{id:"_8️⃣-不同数据类型的总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8️⃣-不同数据类型的总结"}},[t._v("#")]),t._v(" 8️⃣ 不同数据类型的总结")]),t._v(" "),e("h3",{attrs:{id:"整型-支持的运算符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#整型-支持的运算符"}},[t._v("#")]),t._v(" 整型 支持的运算符")]),t._v(" "),e("ul",[e("li",[t._v("比较运算符: "),e("code",[t._v("<=")]),t._v(" , "),e("code",[t._v("<")]),t._v(" , "),e("code",[t._v("==")]),t._v(" , "),e("code",[t._v("!=")]),t._v(" , "),e("code",[t._v(">=")]),t._v(" , "),e("code",[t._v(">")]),t._v(" 比较结果的返回值为 bool 类型")]),t._v(" "),e("li",[t._v("位运算符："),e("code",[t._v("&")]),t._v(" ，"),e("code",[t._v("|")]),t._v("，"),e("code",[t._v("^")]),t._v("（异或），"),e("code",[t._v("~")]),t._v("（非,位取反）")]),t._v(" "),e("li",[t._v("移位运算符: "),e("code",[t._v("<<")]),t._v("（左移） ， "),e("code",[t._v(">>")]),t._v("(右移)")]),t._v(" "),e("li",[t._v("数学运算：\n"),e("ul",[e("li",[e("code",[t._v("+")]),t._v("，"),e("code",[t._v("-")]),t._v("， 一元运算负 "),e("code",[t._v("-")]),t._v(" （仅针对有符号整型）,"),e("code",[t._v("*")]),t._v("，"),e("code",[t._v("/")]),t._v("，"),e("code",[t._v("%")]),t._v("(取余)，")]),t._v(" "),e("li",[e("code",[t._v("++")]),t._v(","),e("code",[t._v("--")]),t._v(","),e("code",[t._v("+=")]),t._v(","),e("code",[t._v("-=")])]),t._v(" "),e("li",[e("code",[t._v("**")]),t._v("（次方）")])])])]),t._v(" "),e("h3",{attrs:{id:"定长浮点型-支持的运算符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定长浮点型-支持的运算符"}},[t._v("#")]),t._v(" 定长浮点型 支持的运算符")]),t._v(" "),e("p",[t._v("比较运算符："),e("code",[t._v("<=")]),t._v("， "),e("code",[t._v("<")]),t._v("， "),e("code",[t._v("==")]),t._v("， "),e("code",[t._v("!=")]),t._v("， "),e("code",[t._v(">=")]),t._v("， "),e("code",[t._v(">")]),t._v(" （返回值是布尔型）\n算术运算符："),e("code",[t._v("+")]),t._v("， "),e("code",[t._v("-")]),t._v("， 一元运算 "),e("code",[t._v("-")]),t._v("， 一元运算 "),e("code",[t._v("+")]),t._v("， "),e("code",[t._v("*")]),t._v("， "),e("code",[t._v("/")]),t._v("， "),e("code",[t._v("%")]),t._v(" （取余数）")]),t._v(" "),e("ul",[e("li",[t._v("比较："),e("code",[t._v("==")]),t._v("，"),e("code",[t._v("!=")]),t._v("，"),e("code",[t._v(">")]),t._v("，"),e("code",[t._v(">=")]),t._v("，"),e("code",[t._v("<")]),t._v("，"),e("code",[t._v("<=")]),t._v(" "),e("ul",[e("li",[t._v("返回值为 bool 类型。")])])]),t._v(" "),e("li",[t._v("位运算符："),e("code",[t._v("&")]),t._v("，"),e("code",[t._v("|")]),t._v("，"),e("code",[t._v("^")]),t._v("(异或)，"),e("code",[t._v("~")]),t._v("非")])]),t._v(" "),e("h2",{attrs:{id:"️⃣-问答题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#️⃣-问答题"}},[t._v("#")]),t._v(" #️⃣ 问答题")]),t._v(" "),e("ul",[e("li",[t._v("算数运算符的注意\n"),e("ul",[e("li",[t._v("表达式 "),e("code",[t._v("-x")]),t._v(" 相当于 "),e("code",[t._v("(T(0) - x)")]),t._v(" 这里 "),e("code",[t._v("T")]),t._v(" 是指 "),e("code",[t._v("x")]),t._v(" 的类型。 "),e("code",[t._v("-x")]),t._v(" 只能应用在有符号型的整数上。")]),t._v(" "),e("li",[t._v("整数除法总是产生整数。")])])]),t._v(" "),e("li",[t._v("一元运算负 "),e("code",[t._v("-")]),t._v(" 有什么需要注意的\n"),e("ul",[e("li",[t._v("表达式 "),e("code",[t._v("-x")]),t._v(" 相当于 "),e("code",[t._v("(T(0) - x)")]),t._v(" 这里 "),e("code",[t._v("T")]),t._v(" 是指 "),e("code",[t._v("x")]),t._v(" 的类型。 "),e("code",[t._v("-x")]),t._v(" 只能应用在有符号型的整数上。 如果 "),e("code",[t._v("x")]),t._v(" 为负数， "),e("code",[t._v("-x")]),t._v(" 为正数。")]),t._v(" "),e("li",[t._v("由于使用两进制补码表示数据，你还需要小心:如果有 "),e("code",[t._v("int x = type(int).min;")]),t._v("， 那 "),e("code",[t._v("-x")]),t._v(" 将不在正数取值的范围内。 这意味着这个检测 "),e("code",[t._v("unchecked { assert(-x == x); }")]),t._v(" 是可以通过的（即这种情况下，不能假设它的负数会是正数），如果是 checked 模式，则会触发异常。")])])])])])}),[],!1,null,null,null);e.default=v.exports}}]);