(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{446:function(e,t,n){"use strict";n.r(t);var a=n(2),s=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_11-合约调用合约"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-合约调用合约"}},[e._v("#")]),e._v(" 11.合约调用合约")]),e._v(" "),t("p",[e._v("Solidity 支持一个合约调用另一个合约。两个合约既可以位于同一文件内，也可以位于不同的两个文件中。还能调用已经上链的其它合约。")]),e._v(" "),t("ul",[t("li",[e._v("调用内部合约\n"),t("ul",[t("li",[e._v("内部合约指：位于同一 sol 文件中的合约，它们不需要额外的声明就可以直接调用。")])])]),e._v(" "),t("li",[e._v("调用外部合约\n"),t("ul",[t("li",[e._v("外部合约指：位于不同文件的外部合约，以及上链的合约。")]),e._v(" "),t("li",[e._v("方法一: 通过接口方式调用")]),e._v(" "),t("li",[e._v("方法二: 通过签名方式调用")])])])]),e._v(" "),t("p",[e._v("了解上面的调用后，可以扩展了解"),t("strong",[e._v("多次调用")])]),e._v(" "),t("h2",{attrs:{id:"_1️⃣-调用内部合约"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1️⃣-调用内部合约"}},[e._v("#")]),e._v(" 1️⃣ 调用内部合约")]),e._v(" "),t("p",[e._v("地址转换为合约对象的防范：")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("方法 1")]),e._v(": 通过 "),t("code",[e._v("ContractName(_ads)")]),e._v(" 将传入的地址，转为合约对象\n"),t("ul",[t("li",[t("code",[e._v("Test(_ads).setX(_x);")])]),e._v(" "),t("li",[e._v("如果为了代码逻辑，也可以分开写，比如"),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Test temp = Test(_ads);\ntemp.setX(_x);\n")])])])])])]),e._v(" "),t("li",[t("strong",[e._v("方法 2")]),e._v(": 可以通过参数中指定合约名字进行转换"),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  function setX2(Test _ads, uint256 _x) public {\n      _ads.setX(_x);\n  }\n")])])])]),e._v(" "),t("li",[t("strong",[e._v("调用并发送 ETH")]),e._v(": "),t("code",[e._v("fnName{value: msg.value}();")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("Test(_ads).setYBySendEth{value: msg.value}();")])])])])]),e._v(" "),t("p",[e._v("例子演示：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Test {\n    uint256 public x = 1;\n    uint256 public y = 2;\n\n    function setX(uint256 _x) public {\n        x = _x;\n    }\n\n    function getX() public view returns (uint256) {\n        return x;\n    }\n\n    function setYBySendEth() public payable {\n        y = msg.value;\n    }\n\n    function getXandY() public view returns (uint256, uint256) {\n        return (x, y);\n    }\n}\n\ncontract CallTest {\n    // 第1种方法: 229647 / 27858 gas\n    function setX1(address _ads, uint256 _x) public {\n        Test(_ads).setX(_x);\n    }\n\n    // 第2种方法:   27923 gas\n    function setX2(Test _ads, uint256 _x) public {\n        _ads.setX(_x);\n    }\n\n    function getX(address _ads) public view returns (uint256) {\n        return Test(_ads).getX();\n    }\n\n    function setYBySendEth(address _ads) public payable {\n        Test(_ads).setYBySendEth{value: msg.value}();\n    }\n\n    function getXandY(address _ads)\n        public\n        view\n        returns (uint256 __x, uint256 __y)\n    {\n        (__x, __y) = Test(_ads).getXandY();\n    }\n}\n")])])]),t("h2",{attrs:{id:"_2️⃣-调用外部合约"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2️⃣-调用外部合约"}},[e._v("#")]),e._v(" 2️⃣ 调用外部合约")]),e._v(" "),t("h3",{attrs:{id:"_1-通过接口方式调用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-通过接口方式调用"}},[e._v("#")]),e._v(" 1. 通过接口方式调用")]),e._v(" "),t("p",[t("RouterLink",{attrs:{to:"/source/13.interface.html#id3"}},[e._v("接口使用案例")])],1),e._v(" "),t("p",[e._v("核心代码")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("interface AnimalEat {\n    function eat() external returns (string memory);\n}\n\ncontract Animal {\n    function test(address _addr) external returns (string memory) {\n        AnimalEat general = AnimalEat(_addr);\n        return general.eat();\n    }\n}\n")])])]),t("h3",{attrs:{id:"_2-通过签名方式调用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-通过签名方式调用"}},[e._v("#")]),e._v(" 2. 通过签名方式调用")]),e._v(" "),t("p",[e._v("通过签名方式调用合约，只需要传入被调用者的地址和调用方法声明。")]),e._v(" "),t("p",[e._v("在第二章地址类型那一节有详细的介绍")]),e._v(" "),t("ul",[t("li",[e._v("使用 "),t("RouterLink",{attrs:{to:"/source/02.type-of-data.html#call"}},[e._v("call")])],1),e._v(" "),t("li",[e._v("使用 "),t("RouterLink",{attrs:{to:"/source/02.type-of-data.html#delegatecall"}},[e._v("delegatecall")])],1),e._v(" "),t("li",[e._v("使用 "),t("RouterLink",{attrs:{to:"/source/02.type-of-data.html#staticcall"}},[e._v("staticcall")])],1)]),e._v(" "),t("p",[t("strong",[e._v("call 核心代码如下")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('bytes memory data = abi.encodeWithSignature(\n    "setNameAndAge(string,uint256)",\n    _name,\n    _age\n);\n(bool success, bytes memory _bys) = _ads.call{value: msg.value}(data);\nrequire(success, "Call Failed");\nbys = _bys;\n')])])]),t("p",[e._v("用给定的有效载荷（payload）发出低级 "),t("code",[e._v("CALL")]),e._v(" 调用，并"),t("strong",[e._v("返回交易成功状态和返回数据")]),e._v("（调用合约的方法并转账）, 格式如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<address>.call(bytes memory) returns (bool, bytes memory)\n")])])]),t("p",[t("strong",[e._v("DelegateCall 核心代码如下")])]),e._v(" "),t("ul",[t("li",[e._v("委托调用后，所有变量修改都是发生在委托合约内部，并不会保存在被委托合约中。\n"),t("ul",[t("li",[e._v("利用这个特性，可以通过更换被委托合约，来升级委托合约。")])])]),e._v(" "),t("li",[e._v("委托调用合约内部，需要和被委托合约的内部参数完全一样，否则容易导致数据混乱\n"),t("ul",[t("li",[e._v("可以通过顺序来避免这个问题，但是推荐完全一样")])])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('function set(address _ads, uint256 _num) external payable {\n    sender = msg.sender;\n    value = msg.value;\n    num = _num;\n    // 第1种 encode\n    // 不需知道合约名字，函数完全自定义\n    bytes memory data1 = abi.encodeWithSignature("set(uint256)", _num);\n    // 第2种 encode\n    // 需要合约名字，可以避免函数和参数写错\n    // bytes memory data2 = abi.encodeWithSelector(Test1.set.selector, _num);\n\n    (bool success, bytes memory _data) = _ads.delegatecall(data1);\n\n    require(success, "DelegateCall set failed");\n}\n')])])]),t("p",[t("strong",[e._v("staticcall 核心代码如下")]),e._v(": 它与 call 基本相同，"),t("strong",[e._v("但如果被调用的函数以任何方式修改状态变量，都将回退")]),e._v("。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// 被调用的合约\ncontract Hello {\n    function echo() external pure returns (string memory) {\n        return "Hello World!";\n    }\n}\n\n// 调用者合约\ncontract SoldityTest {\n    function callHello(address _ads) external view returns (string memory) {\n        // 编码被调用者的方法签名\n        bytes4 methodId = bytes4(keccak256("echo()"));\n\n        // 调用合约\n        (bool success, bytes memory data) = _ads.staticcall(\n            abi.encodeWithSelector(methodId)\n        );\n        if (success) {\n            return abi.decode(data, (string));\n        } else {\n            return "error";\n        }\n    }\n}\n')])])]),t("h2",{attrs:{id:"_3️⃣-multicall-多次调用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3️⃣-multicall-多次调用"}},[e._v("#")]),e._v(" 3️⃣ MultiCall/多次调用")]),e._v(" "),t("ul",[t("li",[e._v("把多个合约的多次函数的调用，打包在一个里面对合约进行调用。RPC 对调用有限制，这样可以绕开限制。")]),e._v(" "),t("li",[e._v("多次调用里面，对方的内部, "),t("code",[e._v("msg.sender")]),e._v(" 是 MultiCall 合约，而不是用户地址。")])]),e._v(" "),t("h3",{attrs:{id:"说明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#说明"}},[e._v("#")]),e._v(" 说明")]),e._v(" "),t("ul",[t("li",[e._v("调用的地址")]),e._v(" "),t("li",[e._v("调用的 data")])]),e._v(" "),t("h3",{attrs:{id:"合约代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#合约代码"}},[e._v("#")]),e._v(" 合约代码")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Test {\n    function fn1()\n        external\n        view\n        returns (\n            uint256,\n            address,\n            uint256\n        )\n    {\n        return (1, msg.sender, block.timestamp);\n    }\n\n    function fn2()\n        external\n        view\n        returns (\n            uint256,\n            address,\n            uint256\n        )\n    {\n        return (2, msg.sender, block.timestamp);\n    }\n\n    function getFn1Data() external pure returns (bytes memory) {\n        // 两种签名方法都可以\n        // abi.encodeWithSignature("fn1()");\n        return abi.encodeWithSelector(this.fn1.selector);\n    }\n\n    function getFn2Data() external pure returns (bytes memory) {\n        return abi.encodeWithSelector(this.fn2.selector);\n    }\n}\n\ncontract MultiCall {\n    function multiCall(address[] calldata targets, bytes[] calldata data)\n        external\n        view\n        returns (bytes[] memory)\n    {\n        require(targets.length == data.length, "targets.length != data.length");\n        bytes[] memory results = new bytes[](data.length);\n        for (uint256 index = 0; index < targets.length; index++) {\n            (bool success, bytes memory result) = targets[index].staticcall(\n                data[index]\n            );\n            require(success, "call faild");\n            results[index] = result;\n        }\n        return results;\n    }\n}\n')])])]),t("p",[t("strong",[e._v("测试")])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("部署 "),t("code",[e._v("Test")]),e._v(": "),t("code",[e._v("0x1c91347f2A44538ce62453BEBd9Aa907C662b4bD")])]),e._v(" "),t("ul",[t("li",[e._v("使用 "),t("code",[e._v("getFn1Data")]),e._v(" 获取 fn1 data")]),e._v(" "),t("li",[e._v("使用 "),t("code",[e._v("getFn2Data")]),e._v(" 获取 fn2 data")])])]),e._v(" "),t("li",[t("p",[e._v("部署 "),t("code",[e._v("MultiCall")]),e._v(": "),t("code",[e._v("0x93f8dddd876c7dBE3323723500e83E202A7C96CC")])])]),e._v(" "),t("li",[t("p",[e._v("调用 multiCall 方法")]),e._v(" "),t("ul",[t("li",[e._v("参数 1: "),t("code",[e._v('["Test 地址","Test 地址"]')])]),e._v(" "),t("li",[e._v("参数 2: "),t("code",[e._v('["fn1 data","fn2 data"]')])])])]),e._v(" "),t("li",[t("p",[e._v("返回值如下")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("0x\n0000000000000000000000000000000000000000000000000000000000000001\n00000000000000000000000093f8dddd876c7dbe3323723500e83e202a7c96cc\n00000000000000000000000000000000000000000000000000000000630c7834,\n0x\n0000000000000000000000000000000000000000000000000000000000000002\n00000000000000000000000093f8dddd876c7dbe3323723500e83e202a7c96cc\n00000000000000000000000000000000000000000000000000000000630c7834\n")])])])])]),e._v(" "),t("h2",{attrs:{id:"_4️⃣-multidelegatecall-多次委托调用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4️⃣-multidelegatecall-多次委托调用"}},[e._v("#")]),e._v(" 4️⃣ MultiDelegatecall / 多次委托调用")]),e._v(" "),t("p",[e._v("为什么使用 MultiDelegatecall ，不使用 MultiCall?是为了让被调用的合约内，"),t("code",[e._v("msg.sender")]),e._v(" 是用户合约，而不是中转合约的地址。")]),e._v(" "),t("p",[e._v("但是委托调用的缺点是，合约必须是自己编写的，不能是别人编写的。")]),e._v(" "),t("p",[e._v("多次委托调用，存在漏洞，不要在里面多次累加余额。或者多重委托禁止接受资金。")]),e._v(" "),t("h3",{attrs:{id:"合约"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#合约"}},[e._v("#")]),e._v(" 合约")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract MultiDelegatecall {\n    function multiDelegatecall(bytes[] calldata data)\n        external\n        returns (bytes[] memory)\n    {\n        bytes[] memory results = new bytes[](data.length);\n        for (uint256 index = 0; index < data.length; index++) {\n            (bool success, bytes memory result) = address(this).delegatecall(\n                data[index]\n            );\n            require(success, "call faild");\n            results[index] = result;\n        }\n        return results;\n    }\n}\n\ncontract Test is MultiDelegatecall {\n    function fn1()\n        external\n        view\n        returns (\n            uint256,\n            address,\n            uint256\n        )\n    {\n        return (1, msg.sender, block.timestamp);\n    }\n\n    function fn2()\n        external\n        view\n        returns (\n            uint256,\n            address,\n            uint256\n        )\n    {\n        return (2, msg.sender, block.timestamp);\n    }\n\n    function getFn1Data() external pure returns (bytes memory) {\n        // 两种签名方法都可以\n        // abi.encodeWithSignature("fn1()");\n        return abi.encodeWithSelector(this.fn1.selector);\n    }\n\n    function getFn2Data() external pure returns (bytes memory) {\n        return abi.encodeWithSelector(this.fn2.selector);\n    }\n}\n')])])]),t("p",[t("strong",[e._v("合约测试")])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("部署 Test 合约")])]),e._v(" "),t("li",[t("p",[e._v("获取 getFn1Data: "),t("code",[e._v("0x648fc804")])])]),e._v(" "),t("li",[t("p",[e._v("获取 getFn2Data: "),t("code",[e._v("0x98d26a11")])])]),e._v(" "),t("li",[t("p",[e._v("调用 "),t("code",[e._v("multiDelegatecall")])]),e._v(" "),t("ul",[t("li",[e._v('["0x648fc804","0x98d26a11"]')])])]),e._v(" "),t("li",[t("p",[e._v("得到 decoded output，发现地址是用户的")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("0x\n0000000000000000000000000000000000000000000000000000000000000001\n0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4\n00000000000000000000000000000000000000000000000000000000630c8ebc,\n0x\n0000000000000000000000000000000000000000000000000000000000000002\n0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4\n00000000000000000000000000000000000000000000000000000000630c8ebc\n")])])])])]),e._v(" "),t("h2",{attrs:{id:"🆗-实战应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#🆗-实战应用"}},[e._v("#")]),e._v(" 🆗 实战应用")]),e._v(" "),t("h2",{attrs:{id:"️⃣-问答题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#️⃣-问答题"}},[e._v("#")]),e._v(" #️⃣ 问答题")]),e._v(" "),t("ul",[t("li",[e._v("内部合约调用有哪些方法？\n"),t("ul",[t("li",[t("strong",[e._v("方法 1")]),e._v(": 通过 "),t("code",[e._v("ContractName(_ads)")]),e._v(" 将传入的地址，转为合约对象\n"),t("ul",[t("li",[t("code",[e._v("Test(_ads).setX(_x);")])]),e._v(" "),t("li",[e._v("如果为了代码逻辑，也可以分开写，比如"),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Test temp = Test(_ads);\ntemp.setX(_x);\n")])])])])])]),e._v(" "),t("li",[t("strong",[e._v("方法 2")]),e._v(": 可以通过参数中指定合约名字进行转换"),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  function setX2(Test _ads, uint256 _x) public {\n      _ads.setX(_x);\n  }\n")])])])]),e._v(" "),t("li",[t("strong",[e._v("调用并发送 ETH")]),e._v(": "),t("code",[e._v("fnName{value: msg.value}();")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("Test(_ads).setYBySendEth{value: msg.value}();")])])])])])]),e._v(" "),t("li",[e._v("调用外部合约有哪些方法？\n"),t("ul",[t("li",[e._v("1 通过接口方式调用")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  interface AnimalEat {\n      function eat() external returns (string memory);\n  }\n\n  contract Animal {\n      function test(address _addr) external returns (string memory) {\n          AnimalEat general = AnimalEat(_addr);\n          return general.eat();\n      }\n  }\n")])])]),t("ul",[t("li",[e._v("2 通过签名方式调用(call/delegatecall/staticcall)\n"),t("ul",[t("li",[t("strong",[e._v("call 核心代码如下")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('bytes memory data = abi.encodeWithSignature(\n    "setNameAndAge(string,uint256)",\n    _name,\n    _age\n);\n(bool success, bytes memory _bys) = _ads.call{value: msg.value}(data);\nrequire(success, "Call Failed");\nbys = _bys;\n')])])]),t("ul",[t("li",[e._v("用给定的有效载荷（payload）发出低级 "),t("code",[e._v("CALL")]),e._v(" 调用，并"),t("strong",[e._v("返回交易成功状态和返回数据")]),e._v("（调用合约的方法并转账）, 格式如下：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<address>.call(bytes memory) returns (bool, bytes memory)\n")])])]),t("ul",[t("li",[t("p",[t("strong",[e._v("DelegateCall 核心代码如下")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('function set(address _ads, uint256 _num) external payable {\n    sender = msg.sender;\n    value = msg.value;\n    num = _num;\n    // 第1种 encode\n    // 不需知道合约名字，函数完全自定义\n    bytes memory data1 = abi.encodeWithSignature("set(uint256)", _num);\n    // 第2种 encode\n    // 需要合约名字，可以避免函数和参数写错\n    // bytes memory data2 = abi.encodeWithSelector(Test1.set.selector, _num);\n\n    (bool success, bytes memory _data) = _ads.delegatecall(data1);\n\n    require(success, "DelegateCall set failed");\n}\n')])])])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("staticcall 核心代码如下")]),e._v(": 它与 call 基本相同，"),t("strong",[e._v("但如果被调用的函数以任何方式修改状态变量，都将回退")]),e._v("。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('  // SPDX-License-Identifier: MIT\n  pragma solidity ^0.8.17;\n\n  // 被调用的合约\n  contract Hello {\n      function echo() external pure returns (string memory) {\n          return "Hello World!";\n      }\n  }\n\n  // 调用者合约\n  contract SoldityTest {\n      function callHello(address _ads) external view returns (string memory) {\n          // 编码被调用者的方法签名\n          bytes4 methodId = bytes4(keccak256("echo()"));\n\n          // 调用合约\n          (bool success, bytes memory data) = _ads.staticcall(\n              abi.encodeWithSelector(methodId)\n          );\n          if (success) {\n              return abi.decode(data, (string));\n          } else {\n              return "error";\n          }\n      }\n  }\n')])])])])])])])]),e._v(" "),t("li",[e._v("MultiCall/多次调用\n"),t("ul",[t("li",[e._v("把多个合约的多次函数的调用，打包在一个里面对合约进行调用。RPC 对调用有限制，这样可以绕开限制。")]),e._v(" "),t("li",[e._v("多次调用里面，对方的内部, "),t("code",[e._v("msg.sender")]),e._v(" 是 MultiCall 合约，而不是用户地址。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('contract MultiCall {\n      function multiCall(address[] calldata targets, bytes[] calldata data)\n          external\n          view\n          returns (bytes[] memory)\n      {\n          require(targets.length == data.length, "targets.length != data.length");\n          bytes[] memory results = new bytes[](data.length);\n          for (uint256 index = 0; index < targets.length; index++) {\n              (bool success, bytes memory result) = targets[index].staticcall(\n                  data[index]\n              );\n              require(success, "call faild");\n              results[index] = result;\n          }\n          return results;\n      }\n  }\n')])])])]),e._v(" "),t("li",[e._v("MultiDelegatecall / 多次委托调用\n"),t("ul",[t("li",[e._v("为什么使用 MultiDelegatecall ，不使用 MultiCall?是为了让被调用的合约内，"),t("code",[e._v("msg.sender")]),e._v(" 是用户合约，而不是中转合约的地址。但是委托调用的缺点是，合约必须是自己编写的，不能是别人编写的。多次委托调用，存在漏洞，不要在里面多次累加余额。或者多重委托禁止接受资金。"),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract MultiDelegatecall {\n    function multiDelegatecall(bytes[] calldata data)\n        external\n        returns (bytes[] memory)\n    {\n        bytes[] memory results = new bytes[](data.length);\n        for (uint256 index = 0; index < data.length; index++) {\n            (bool success, bytes memory result) = address(this).delegatecall(\n                data[index]\n            );\n            require(success, "call faild");\n            results[index] = result;\n        }\n        return results;\n    }\n}\n\ncontract Test is MultiDelegatecall {\n    function fn1()\n        external\n        view\n        returns (\n            uint256,\n            address,\n            uint256\n        )\n    {\n        return (1, msg.sender, block.timestamp);\n    }\n\n    function fn2()\n        external\n        view\n        returns (\n            uint256,\n            address,\n            uint256\n        )\n    {\n        return (2, msg.sender, block.timestamp);\n    }\n\n    function getFn1Data() external pure returns (bytes memory) {\n        // 两种签名方法都可以\n        // abi.encodeWithSignature("fn1()");\n        return abi.encodeWithSelector(this.fn1.selector);\n    }\n\n    function getFn2Data() external pure returns (bytes memory) {\n        return abi.encodeWithSelector(this.fn2.selector);\n    }\n}\n')])])])])])])])])}),[],!1,null,null,null);t.default=s.exports}}]);