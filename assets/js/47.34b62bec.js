(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{453:function(n,t,e){"use strict";e.r(t);var a=e(2),s=Object(a.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"_21-gas-优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_21-gas-优化"}},[n._v("#")]),n._v(" 21.Gas 优化")]),n._v(" "),t("h2",{attrs:{id:"_1️⃣-省钱总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1️⃣-省钱总结"}},[n._v("#")]),n._v(" 1️⃣ 省钱总结")]),n._v(" "),t("ul",[t("li",[n._v("使用短路模式来排序操作")]),n._v(" "),t("li",[n._v("函数使用"),t("code",[n._v("external")]),n._v(" + "),t("code",[n._v("calldata")]),n._v(" "),t("ul",[t("li",[n._v("对 "),t("code",[n._v("memory")]),n._v(" 类型的参数，使用 "),t("code",[n._v("external")]),n._v(" 并且参数标注 "),t("code",[n._v("calldata")]),n._v(" 是最省钱的。")])])]),n._v(" "),t("li",[n._v("使用正确的数据类型\n"),t("ul",[t("li",[n._v("gas 由小到大: 值类型 "),t("code",[n._v("<")]),n._v(" 引用类型")])])]),n._v(" "),t("li",[n._v("循环中不操作 "),t("code",[n._v("storage")]),n._v(" 变量")]),n._v(" "),t("li",[n._v("循环中的不重复计算数据\n"),t("ul",[t("li",[n._v("能不在循环中操作的数据，就尽量放在外面计算")])])]),n._v(" "),t("li",[n._v("多个循环可以合并就尽量合并.(循环尽量不用)")]),n._v(" "),t("li",[n._v("可预测的结果,不通过代码计算。")]),n._v(" "),t("li",[n._v("避免死代码")]),n._v(" "),t("li",[n._v("避免不必要的判断")]),n._v(" "),t("li",[n._v("删除不必要的库")]),n._v(" "),t("li",[n._v("函数中能不 retrun，就尽量不 return")]),n._v(" "),t("li",[n._v("库合约使用 using for 比直接使用更省 gas")]),n._v(" "),t("li",[n._v("mapping 的 key 使用 bytes32，而不使用字符串，可以省 Gas；")]),n._v(" "),t("li",[t("code",[n._v("private")]),n._v(" 变量比 "),t("code",[n._v("public")]),n._v("变量更节省 Gas")])]),n._v(" "),t("h2",{attrs:{id:"_2️⃣-使用短路模式来排序操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2️⃣-使用短路模式来排序操作"}},[n._v("#")]),n._v(" 2️⃣ 使用短路模式来排序操作")]),n._v(" "),t("p",[n._v("短路（short-circuiting）是利用逻辑或("),t("code",[n._v("||")]),n._v("),逻辑与("),t("code",[n._v("&&")]),n._v(")的特性，来排序不同成本操作的开发模式；核心是 "),t("strong",[n._v("它将低 gas 成本的操作放在前面，高 gas 成本的操作放在后面")]),n._v("；这样如果前面的低成本操作不可行，就可以跳过（短路）后面的高成本以太坊操作了。")]),n._v(" "),t("ul",[t("li",[n._v("前面判断为 true，执行后面的条件判断")]),n._v(" "),t("li",[n._v("前面判断为 false，跳过后面的条件判断\n"),t("ul",[t("li",[n._v("这样就把后面条件的运行 gas 给节省下来了")])])])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// f(x) 是低gas成本的操作\n// g(y) 是高gas成本的操作\n\n// 按如下排序不同gas成本的操作\nf(x) || g(y)\nf(x) && g(y)\n")])])]),t("p",[n._v("这里哪个判断在前面，哪个判断在后面，需要根据实际情况来安排。")]),n._v(" "),t("p",[t("strong",[n._v("下面是例子")]),n._v("说明,一个非常简单的值判断:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Demo {\n    // gas值如下\n    // 输入 1:   22050\n    // 输入 2:   22065\n    // 输入 101: 22050\n    // 输入 102: 22055\n    // 平均值: (22050+22065+22050+22055)/4 = 22055\n    function test1(uint256 _amount) external pure returns (bool) {\n        bool isEven = _amount % 2 == 0;\n        bool isLessThan99 = _amount < 99;\n        if (isEven && isLessThan99) {\n            return true;\n        }\n        return false;\n    }\n\n    // gas值如下\n    // 输入 1:   22040\n    // 输入 2:   22061\n    // 输入 101: 22040\n    // 输入 102: 22051\n    // 平均值: (22040+22061+22040+22051)/4 = 22048\n    function test2(uint256 _amount) external pure returns (bool) {\n        if (_amount % 2 == 0 && _amount < 99) {\n            return true;\n        }\n        return false;\n    }\n\n    // gas值如下\n    // 输入 1:   22073\n    // 输入 2:   22083\n    // 输入 101: 21881\n    // 输入 102: 21881\n    // 平均值: (22073+22083+21881+21881)/4 = 21979.5 ✅ 平均值最低\n    function test3(uint256 _amount) external pure returns (bool) {\n        if (_amount < 99 && _amount % 2 == 0) {\n            return true;\n        }\n        return false;\n    }\n}\n")])])]),t("h2",{attrs:{id:"_3️⃣-函数使用external-calldata"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3️⃣-函数使用external-calldata"}},[n._v("#")]),n._v(" 3️⃣ 函数使用"),t("code",[n._v("external")]),n._v(" + "),t("code",[n._v("calldata")])]),n._v(" "),t("p",[n._v("在合约开发种，显式声明函数的可见性不仅可以提高智能合约的安全性，同时也有利于优化合约执行的 gas 成本。")]),n._v(" "),t("p",[n._v("例如，通过显式地标记函数为外部函数 "),t("code",[n._v("external")]),n._v("，可以强制将函数参数的存储位置设置为 calldata，这会节约每次函数执行时所需的以太坊 gas 成本。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Demo {\n    // gas值如下\n    // 输入 a       :   22965\n    // 输入 abc     :   22989\n    // 输入 hello   :   23013\n    // 平均值: (22965+22989+23013)/3 = 22989\n    function test1(string memory _str) public pure returns (string memory) {\n        return _str;\n    }\n\n    // gas值如下\n    // 输入 a       :   22943\n    // 输入 abc     :   22967\n    // 输入 hello   :   22991\n    // 平均值: (22943+22967+22991)/3 = 22967\n    function test2(string memory _str) external pure returns (string memory) {\n        return _str;\n    }\n\n    // gas值如下\n    // 输入 a       :   22705\n    // 输入 abc     :   22729\n    // 输入 hello   :   22753\n    // 平均值: (22705+22729+22753)/3 = 22729 ✅ 平均值最低\n    function test3(string calldata _str) external pure returns (string memory) {\n        return _str;\n    }\n}\n")])])]),t("p",[n._v("注意这种方法只对 "),t("code",[n._v("memory")]),n._v(" 类型的数据有效，如果是操作普通的类型，可见性没有影响。如下例子我将上面短路操作例子中 "),t("code",[n._v("external")]),n._v(" 改为 "),t("code",[n._v("public")]),n._v(",所消耗的 gas 并没有任何影响")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Demo {\n    // gas值如下\n    // 输入 1:   22050  | 改为 public 后: 22050\n    // 输入 2:   22065  | 改为 public 后: 22065\n    // 输入 101: 22050  | 改为 public 后: 22050\n    // 输入 102: 22055  | 改为 public 后: 22055\n    // 平均值: (22050+22065+22050+22055)/4 = 22055\n    function test1(uint256 _amount) public pure returns (bool) {\n        bool isEven = _amount % 2 == 0;\n        bool isLessThan99 = _amount < 99;\n        if (isEven && isLessThan99) {\n            return true;\n        }\n        return false;\n    }\n\n    // gas值如下\n    // 输入 1:   22040  | 改为 public 后: 22040\n    // 输入 2:   22061  | 改为 public 后: 22061\n    // 输入 101: 22040  | 改为 public 后: 22040\n    // 输入 102: 22051  | 改为 public 后: 22051\n    // 平均值: (22040+22061+22040+22051)/4 = 22048\n    function test2(uint256 _amount) public pure returns (bool) {\n        if (_amount % 2 == 0 && _amount < 99) {\n            return true;\n        }\n        return false;\n    }\n\n    // gas值如下\n    // 输入 1:   22073  | 改为 public 后: 22073\n    // 输入 2:   22083  | 改为 public 后: 22083\n    // 输入 101: 21881  | 改为 public 后: 21881\n    // 输入 102: 21881  | 改为 public 后: 21881\n    // 平均值: (22073+22083+21881+21881)/4 = 21979.5 ✅ 平均值最低\n    function test3(uint256 _amount) public pure returns (bool) {\n        if (_amount < 99 && _amount % 2 == 0) {\n            return true;\n        }\n        return false;\n    }\n}\n")])])]),t("h2",{attrs:{id:"_4️⃣-使用正确的数据类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4️⃣-使用正确的数据类型"}},[n._v("#")]),n._v(" 4️⃣ 使用正确的数据类型")]),n._v(" "),t("p",[n._v("有些数据类型要比另外一些数据类型的 gas 成本高。我们有必要了解可用数据类型的 gas 利用情况，以便根据你的需求选择效率最高的那种。下面是关于数据类型 gas 消耗情况的一些规则：")]),n._v(" "),t("ul",[t("li",[n._v("在任何可以使用 "),t("code",[n._v("uint256")]),n._v(" 类型的情况下，不要使用 "),t("code",[n._v("string")]),n._v(" 类型")]),n._v(" "),t("li",[n._v("存储 "),t("code",[n._v("uint256")]),n._v(" 要比存储 "),t("code",[n._v("uint8")]),n._v(" 的 gas 成本低，为什么？点击这里 "),t("a",{attrs:{href:"https://ethereum.stackexchange.com/questions/3067/why-does-uint8-cost-more-gas-than-uint256",target:"_blank",rel:"noopener noreferrer"}},[n._v("查看原文"),t("OutboundLink")],1)]),n._v(" "),t("li",[n._v("当可以使用 "),t("code",[n._v("bytes32")]),n._v(" 类型时，不要使用"),t("code",[n._v("byte[]")]),n._v(" 类型")]),n._v(" "),t("li",[n._v("如果 "),t("code",[n._v("bytes32")]),n._v(" 的长度有可以预计的上限，那么尽可能改用 "),t("code",[n._v("bytes1")]),n._v("~"),t("code",[n._v("bytes32")]),n._v(" 这些具有固定长度的类型")]),n._v(" "),t("li",[t("code",[n._v("bytes32")]),n._v(" 所需的 gas 成本要低于 "),t("code",[n._v("string")]),n._v(" 类型")]),n._v(" "),t("li",[t("code",[n._v("bool > unit256 > uint8 > bytes1 > bytes32 > bytes > string")])])]),n._v(" "),t("h3",{attrs:{id:"存储对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#存储对比"}},[n._v("#")]),n._v(" 存储对比")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Demo {\n    uint256 public test3 = 0; // 23494\n    uint8 public test1 = 0; // 23554\n    bool public test2 = false; // 23630\n    bytes1 public test4 = 0x30; // 23601\n    // 23516\n    bytes32 public test5 =\n        0x3000000000000000000000000000000000000000000000000000000000000000;\n    string public test7 = "0"; // 24487\n    bytes public test6 = bytes("0"); // 24531\n}\n')])])]),t("h3",{attrs:{id:"返回对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#返回对比"}},[n._v("#")]),n._v(" 返回对比")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Demo {\n    // uint256 :21415\n    function test1() external pure returns (uint256) {\n        return 0;\n    }\n\n    // uint8 : 21444\n    function test2() external pure returns (uint8) {\n        return 0;\n    }\n\n    // bool :21400\n    function test3() external pure returns (bool) {\n        return false;\n    }\n\n    // bytes1 :21479\n    function test4() external pure returns (bytes1) {\n        return 0x30;\n    }\n\n    // bytes32 :21430\n    function test5() external pure returns (bytes32) {\n        return\n            0x3000000000000000000000000000000000000000000000000000000000000000;\n    }\n\n    // bytes :21845\n    function test6() external pure returns (bytes memory) {\n        return bytes("0");\n    }\n\n    // string :21801\n    function test7() external pure returns (string memory) {\n        return "0";\n    }\n}\n')])])]),t("h2",{attrs:{id:"_5️⃣-循环中不操作-storage-变量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5️⃣-循环中不操作-storage-变量"}},[n._v("#")]),n._v(" 5️⃣ 循环中不操作 "),t("code",[n._v("storage")]),n._v(" 变量")]),n._v(" "),t("p",[n._v("管理 storage 变量的 gas 成本要远远高于内存变量，所以要避免在循环中操作 storage 变量。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Demo {\n    uint256 public num = 0;\n\n    // 输入 5 : 46475 gas\n    function test1(uint256 x) public {\n        for (uint256 i = 0; i < x; i++) {\n            num += 1;\n        }\n    }\n\n    // 输入 5 : 45651 gas\n    function test2(uint256 x) public {\n        uint256 temp = num;\n        for (uint256 i = 0; i < x; i++) {\n            temp += 1;\n        }\n        num = temp;\n    }\n}\n")])])]),t("h2",{attrs:{id:"_6️⃣-循环中的不重复计算数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6️⃣-循环中的不重复计算数据"}},[n._v("#")]),n._v(" 6️⃣ 循环中的不重复计算数据")]),n._v(" "),t("ul",[t("li",[n._v("能不在循环中操作的数据，就尽量放在外面计算")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Demo {\n    uint256 a = 4;\n    uint256 b = 5;\n\n    function repeatedComputations(uint256 x) public view returns (uint256) {\n        uint256 sum = 0;\n        for (uint256 i = 0; i <= x; i++) {\n            sum = sum + a * b;\n        }\n    }\n}\n\n")])])]),t("h2",{attrs:{id:"_7️⃣-尽量少用循环"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7️⃣-尽量少用循环"}},[n._v("#")]),n._v(" 7️⃣ 尽量少用循环")]),n._v(" "),t("p",[t("strong",[n._v("多个循环可以合并就尽量合并，循环尽量不用")])]),n._v(" "),t("p",[n._v("有时候在 Solidity 智能合约中，你会发现两个循环的判断条件一致，那么在这种情况下就没有理由不合并它们。例如下面的以太坊合约代码：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Demo {\n    function loopFusion(uint256 x, uint256 y) public pure returns (uint256) {\n        for (uint256 i = 0; i < 100; i++) {\n            x += 1;\n        }\n        for (uint256 i = 0; i < 100; i++) {\n            y += 1;\n        }\n        return x + y;\n    }\n}\n")])])]),t("h2",{attrs:{id:"_8️⃣-可预测的结果-不通过代码计算。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8️⃣-可预测的结果-不通过代码计算。"}},[n._v("#")]),n._v(" 8️⃣ 可预测的结果,不通过代码计算。")]),n._v(" "),t("p",[n._v("如果一个循环计算的结果是无需编译执行代码就可以预测的，那么就不要使用循环，这可以可观地节省 gas。")]),n._v(" "),t("p",[n._v("例如下面的以太坊合约代码就可以直接设置 num 变量的值：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Demo {\n    function constantOutcome() public pure returns (uint256) {\n        uint256 num = 0;\n        for (uint256 i = 0; i < 100; i++) {\n            num += 1;\n        }\n        return num;\n    }\n}\n\n")])])]),t("h2",{attrs:{id:"_9️⃣-避免死代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9️⃣-避免死代码"}},[n._v("#")]),n._v(" 9️⃣ 避免死代码")]),n._v(" "),t("p",[n._v("死代码（Dead code）是指那些永远也不会执行的 Solidity 代码，例如那些执行条件永远也不可能满足的代码，就像下面的两个自相矛盾的条件判断里的代码块，消耗了以太坊 gas 资源但没有任何作用：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("if (x < 1) {\n    if (x > 2) {\n        return x;\n    }\n}\n")])])]),t("h2",{attrs:{id:"🔟-避免不必要的判断"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#🔟-避免不必要的判断"}},[n._v("#")]),n._v(" 🔟 避免不必要的判断")]),n._v(" "),t("p",[n._v("有些条件断言的结果不需要代码的执行就可以了解，那么这样的条件判断就可以精简掉。例如下面的 Solidity 合约代码中的两级判断条件，最外层的判断是在浪费宝贵的以太坊 gas 资源：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v(" if(x < 1) {\n    if(x < 0) {\n      return x;\n    }\n  }\n")])])]),t("h2",{attrs:{id:"_1️⃣-删除不必要的库"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1️⃣-删除不必要的库"}},[n._v("#")]),n._v(" 1️⃣ 删除不必要的库")]),n._v(" "),t("p",[n._v("在开发 Solidity 智能合约时，我们引入的库通常只需要用到其中的部分功能，这意味着其中可能会包含大量对于我们的智能合约而言是冗余代码。如果可以在自己的合约里安全有效地实现所依赖的库功能，那么就能够达到优化合约的 gas 利用的目的。")]),n._v(" "),t("p",[n._v("例如，在下面的 solidity 代码中，我们的以太坊合约只是用到了 SafeMath 库的 add 方法：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import './SafeMath.sol' as SafeMath;\n\ncontract SafeAddition {\n  function safeAdd(uint a, uint b) public pure returns(uint) {\n    return SafeMath.add(a, b);\n  }\n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('contract SafeAddition {\n  function safeAdd(uint a, uint b) public pure returns(uint) {\n    uint c = a + b;\n    require(c >= a, "Addition overflow");\n    return c;\n  }\n}\n')])])]),t("h2",{attrs:{id:"🆗-优化案例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#🆗-优化案例"}},[n._v("#")]),n._v(" 🆗 优化案例")]),n._v(" "),t("p",[n._v("本篇主要介绍 gas 的优化。")]),n._v(" "),t("ul",[t("li",[n._v("函数输入参数:使用 "),t("code",[n._v("calldata")]),n._v(" ，不使用 "),t("code",[n._v("memory")]),n._v("。")]),n._v(" "),t("li",[n._v("读取状态变量:使用。")]),n._v(" "),t("li",[n._v("使用数组时候:\n"),t("ul",[t("li",[n._v("for 循环时，缓存数组长度")]),n._v(" "),t("li",[n._v("储存数组的元素到 "),t("code",[n._v("memory")]),n._v("。")])])]),n._v(" "),t("li",[n._v("short circuit: "),t("code",[n._v("&&")]),n._v(" 短路操作\n"),t("ul",[t("li",[t("code",[n._v("A && B")]),n._v(",A 表达式 不成立，则不计算 B 表达式")])])]),n._v(" "),t("li",[n._v("loop increments")])]),n._v(" "),t("p",[n._v("下面默认的 Gas 是 50518 gas")]),n._v(" "),t("p",[t("strong",[n._v("原始代码:")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Gas {\n    uint256 public total;\n\n    // [1,2,3,4,5,100]\n    function demo(uint256[] memory nums) external {\n        for (uint256 index = 0; index < nums.length; index++) {\n            bool isEven = nums[index] % 2 == 0;\n            bool isLessThan99 = nums[index] < 99;\n            if (isEven && isLessThan99) {\n                total += nums[index];\n            }\n        }\n    }\n}\n/**\n  * 默认: 50518 gas\n  */\n")])])]),t("p",[t("strong",[n._v("优化后")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract Gas {\n    uint256 public total;\n\n    // [1,2,3,4,5,100]\n    function demo(uint256[] calldata nums) external {\n        uint256 _total = total;\n        uint256 len = nums.length;\n        for (uint256 index = 0; index < len; ++index) {\n            uint256 num = nums[index];\n            if (num % 2 == 0 && num < 99) {\n                _total += num;\n            }\n        }\n        total = _total;\n    }\n}\n\n/**\n * 默认 => 50518 gas\n * 1. 函数参数不使用 memory，改用 calldata\n *      => 48773    节省了 1745\n * 2. 状态变量在函数内不每次都读取和修改，缓存到内存里，统一修改\n *      => 48562    节省了 211\n * 3. 短路(条件 &&)\n *      => 48244    节省了 318\n * 4. 循环增量 i++ 改为 ++i\n *      => 48214    节省了 30\n * 5. 循环时，缓存数组的长度 uint256 len = nums.length;\n *      => 48179    节省了 35\n * 6. 数组的元素，提前缓存，不重复读取\n *      => 48017    节省了 162\n *\n */\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);