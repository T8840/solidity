(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{444:function(n,e,r){"use strict";r.r(e);var t=r(2),a=Object(t.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"_15-算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_15-算法"}},[n._v("#")]),n._v(" 15.算法")]),n._v(" "),e("p",[n._v("此算法参考我之前写的"),e("a",{attrs:{href:"https://github.com/anbang/javascript-notes/blob/8912f7efb4456064456079caa5fdfc573e0109bd/JS%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/JS%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95.md",target:"_blank",rel:"noopener noreferrer"}},[n._v("JS 教程算法"),e("OutboundLink")],1),n._v(",然后做改动。")]),n._v(" "),e("p",[n._v("在 Solidity 内主要是经济模型的算法，在其他语言内的各种排序算法，在合约内使用场景并不是很常见，之所以在这里罗列，是一起熟悉下思路，算法是很基础的逻辑训练途径，下面仅以插入排序喝冒泡排序作为例子。快速排序和数组去重作为扩展练习")]),n._v(" "),e("h2",{attrs:{id:"_1️⃣-插入排序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1️⃣-插入排序"}},[n._v("#")]),n._v(" 1️⃣ 插入排序")]),n._v(" "),e("p",[n._v("插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。")]),n._v(" "),e("p",[n._v("操作步骤：首先选取数组的第一项即 "),e("code",[n._v("ary[0]")]),n._v("，我们可以认为这个数是已经安排好序的，再取 "),e("code",[n._v("ary[1]")]),n._v("项插入到已经排好序的元素中，此时只有 "),e("code",[n._v("ary[0]")]),n._v("，我们比较"),e("code",[n._v("ary[0]")]),n._v("和 "),e("code",[n._v("ary[1]")]),n._v("；大于 "),e("code",[n._v("ary[0]")]),n._v("就放在后面，小于就插到 "),e("code",[n._v("ary[0]")]),n._v(" 前面；要插入的元素依次为"),e("code",[n._v("ary[1]")]),n._v("至"),e("code",[n._v("ary[ary.leng-1]")]),n._v("项；插入到排序好的数组中的时候，插入每一项都需要从后面往前面遍历已经排序好的元素；")]),n._v(" "),e("p",[n._v("如果排序好的元素比插入的元素大，则把该元素往后挪一位，直到已经排序的元素小于等于要插入的元素（或者已经遍历完已经排好序的数组项），则把要插入的元素放在该位置+1 的索引位置中（反向排的时候，需要放在数组的第 0 个位置），对每个插入的元素都执行上面的操作，最终数组就是排序好的；")]),n._v(" "),e("h3",{attrs:{id:"错误版本"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#错误版本"}},[n._v("#")]),n._v(" 错误版本")]),n._v(" "),e("p",[n._v("把原来 "),e("a",{attrs:{href:"https://github.com/anbang/javascript-notes/blob/8912f7efb4456064456079caa5fdfc573e0109bd/JS%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/JS%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95.md#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F",target:"_blank",rel:"noopener noreferrer"}},[n._v("JS 算法"),e("OutboundLink")],1),n._v(" 里写的代码拷贝进来修改后，竟然错了。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// [11,2,31,45,6,78,37,33,21] => [2, 6, 11, 21, 31, 33, 37, 45, 78]\ncontract Demo {\n    function insertSort(uint256[] memory ary)\n        public\n        pure\n        returns (uint256[] memory)\n    {\n        uint256 temp; //定义一个临时变量，保存要插入的值；\n        uint256 len = ary.length;\n        for (uint256 i = 1; i < len; i++) {\n            if (ary[i] < ary[i - 1]) {\n                temp = ary[i]; //需要插入的值；\n                uint256 pIndex = i - 1; //需要插入值的前一个索引；\n                while (temp < ary[pIndex] && pIndex >= 0) {\n                    ary[pIndex + 1] = ary[pIndex]; //相当于ary[i]=ary[i-1];\n                    ary[pIndex] = temp; //相当于ary[i-1]=temp;完成一波交换；\n                    pIndex--; //准备下一波交换；\n                }\n            }\n        }\n        return ary;\n    }\n}\n")])])]),e("p",[n._v("报错信息如下：出现了 "),e("code",[n._v("overflow")]),n._v("了。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('{\n\t"error": "Failed to decode output: Error: overflow (fault=\\"overflow\\", operation=\\"toNumber\\", value=\\"35408467139433450592217433187231851964531694900788300625387963629091585785856\\", code=NUMERIC_FAULT, version=bignumber/5.5.0)"\n}\n')])])]),e("p",[n._v("这个代表超出了 "),e("code",[n._v("uint256")]),n._v("的范围了，"),e("code",[n._v("uint256")]),n._v(" 的范围是 "),e("code",[n._v("0")]),n._v(" 至"),e("code",[n._v("115792089237316195423570985008687907853269984665640564039457584007913129639935")]),n._v("，肯定不是运算超出最大值了，只能是计算时候超出最小值了；基本可以锁定 "),e("code",[n._v("pIndex--;")]),n._v(" 这一句导致的错误，运行到 "),e("code",[n._v("0--")]),n._v(" 等于 -1 ，导致出错了。")]),n._v(" "),e("h3",{attrs:{id:"修复如下"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#修复如下"}},[n._v("#")]),n._v(" 修复如下")]),n._v(" "),e("p",[n._v("原理: 只需要让 "),e("code",[n._v("pIndex--")]),n._v(" 最小运行到 "),e("code",[n._v("1--")]),n._v(" 就可以解决溢出问题了。")]),n._v(" "),e("ul",[e("li",[n._v("而让"),e("code",[n._v("pIndex")]),n._v("最小值等 1，则需要 "),e("code",[n._v("pIndex >= 1")])]),n._v(" "),e("li",[n._v("其他一次修改即可")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// [11,2,31,45,6,78,37,33,21] => [2, 6, 11, 21, 31, 33, 37, 45, 78]\ncontract Demo {\n    function insertSort(uint256[] memory ary)\n        public\n        pure\n        returns (uint256[] memory)\n    {\n        uint256 temp; //定义一个临时变量，保存要插入的值；\n        uint256 len = ary.length;\n        for (uint256 i = 1; i < len; i++) {\n            if (ary[i] < ary[i - 1]) {\n                temp = ary[i]; //需要插入的值；\n                // 原代码\n                // uint256 pIndex = i - 1; //需要插入值的前一个索引；\n                // while (temp < ary[pIndex] && pIndex >= 0) {\n\n                // 新代码\n                uint256 pIndex = i;\n                while (temp < ary[pIndex - 1] && pIndex >= 1) {\n                    // 原代码\n                    // ary[pIndex + 1] = ary[pIndex]; //相当于ary[i]=ary[i-1];\n                    // ary[pIndex] = temp; //相当于ary[i-1]=temp;完成一波交换；\n\n                    // 新代码\n                    ary[pIndex] = ary[pIndex - 1]; //相当于ary[i]=ary[i-1];\n                    ary[pIndex - 1] = temp; //相当于ary[i-1]=temp;完成一波交换；\n                    pIndex--; //准备下一波交换；\n                }\n            }\n        }\n        return ary;\n    }\n}\n")])])]),e("p",[n._v("但是这个版本的代码还是有问题的，因为我们代码中的 "),e("code",[n._v("temp < ary[pIndex - 1] && pIndex >= 1")]),n._v(" 这里的 "),e("code",[n._v("temp < ary[pIndex - 1]")]),n._v(" 在 "),e("code",[n._v("pIndex--;")]),n._v("后 "),e("code",[n._v("pIndex")]),n._v(" 为 0，而此时 "),e("code",[n._v("ary[pIndex - 1]")]),n._v(" 又出现错误了。")]),n._v(" "),e("h3",{attrs:{id:"再次修复如下"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#再次修复如下"}},[n._v("#")]),n._v(" 再次修复如下")]),n._v(" "),e("p",[n._v("这时候我们需要使用短路规则，把条件位置换一下，因为我们要求 "),e("code",[n._v("pIndex >= 1")]),n._v(",当 "),e("code",[n._v("pIndex")]),n._v(" 为 0 时候就不需要继续运行了。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// [11,2,31,45,6,78,37,33,21] => [2, 6, 11, 21, 31, 33, 37, 45, 78]\ncontract Demo {\n    // 47897 gas\n    function insertSort(uint256[] memory ary)\n        public\n        pure\n        returns (uint256[] memory)\n    {\n        uint256 temp; //定义一个临时变量，保存要插入的值；\n        uint256 len = ary.length;\n        for (uint256 i = 1; i < len; i++) {\n            if (ary[i] < ary[i - 1]) {\n                temp = ary[i]; //需要插入的值；\n                uint256 pIndex = i;\n                while (pIndex >= 1 && temp < ary[pIndex - 1]) {\n                    ary[pIndex] = ary[pIndex - 1]; //相当于ary[i]=ary[i-1];\n                    ary[pIndex - 1] = temp; //相当于ary[i-1]=temp;完成一波交换；\n                    pIndex--; //准备下一波交换；\n                }\n            }\n        }\n        return ary;\n    }\n}\n")])])]),e("p",[n._v("这下终于执行成功了。 查看调用成功的 gas，花费了 "),e("code",[n._v("47897 gas")]),n._v("；")]),n._v(" "),e("p",[n._v("然后我们再次开始怎么优化这些 gas。")]),n._v(" "),e("h3",{attrs:{id:"优化后的最终版本"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优化后的最终版本"}},[n._v("#")]),n._v(" 优化后的最终版本")]),n._v(" "),e("p",[n._v("然后我们再看看怎么优化，")]),n._v(" "),e("ul",[e("li",[e("code",[n._v("if (ary[i] < ary[i - 1])")]),n._v(" 与 "),e("code",[n._v("temp < ary[pIndex - 1]")]),n._v(" 重复判断了")]),n._v(" "),e("li",[n._v("输入变量的位置 memory，可以改为 "),e("code",[n._v("calldata")])]),n._v(" "),e("li",[e("code",[n._v("i++")]),n._v(" 可以改为 "),e("code",[n._v("++")]),n._v(";")]),n._v(" "),e("li",[e("code",[n._v("pIndex--;")]),n._v(" 可以改为 "),e("code",[n._v("--pIndex;")])]),n._v(" "),e("li",[n._v("内部声明的所有变量，都可以提到循环外")])]),n._v(" "),e("p",[n._v("最终的版本: gas 消耗从最开始的 "),e("code",[n._v("47897 gas")]),n._v(" 优化成了 "),e("code",[n._v("41125 gas")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// [11,2,31,45,6,78,37,33,21]\n//           => [2, 6, 11, 21, 31, 33, 37, 45, 78]\n// 47897 gas\n// ...\n// 41125 gas\ncontract Demo {\n    // 47897 gas\n    function insertSort(uint256[] calldata ary)\n        public\n        pure\n        returns (uint256[] memory)\n    {\n        uint256[] memory tempArr = ary;\n        uint256 temp; //定义一个临时变量，保存要插入的值；\n        uint256 len = tempArr.length;\n        uint256 pIndex; // 上一个值\n        for (uint256 i = 1; i < len; ++i) {\n            temp = tempArr[i]; //需要插入的值；\n            pIndex = i;\n            while (pIndex >= 1 && temp < tempArr[pIndex - 1]) {\n                tempArr[pIndex] = tempArr[pIndex - 1]; //相当于ary[i]=ary[i-1];\n                --pIndex; //准备下一波交换；\n            }\n            tempArr[pIndex] = temp; //相当于ary[i-1]=temp; 因为上面 pIndex-- 了\n        }\n        return tempArr;\n    }\n}\n")])])]),e("h2",{attrs:{id:"_2️⃣-冒泡排序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2️⃣-冒泡排序"}},[n._v("#")]),n._v(" 2️⃣ 冒泡排序")]),n._v(" "),e("p",[n._v("冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n算法步骤：")]),n._v(" "),e("ul",[e("li",[n._v("1）比较相邻的元素。如果第一个比第二个大，就交换他们两个。")]),n._v(" "),e("li",[n._v("2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。")]),n._v(" "),e("li",[n._v("3）针对所有的元素重复以上的步骤，除了最后一个。")]),n._v(" "),e("li",[n._v("4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("contract Demo2 {\n    function sortAry(uint256[] calldata ary)\n        public\n        pure\n        returns (uint256[] memory)\n    {\n        uint256[] memory tempArr = ary;\n        uint256 len = tempArr.length; //获取数组的长度；有aryLen个数在排序；\n        uint256 temp; //临时变量，交换数据中用的\n        bool flag = false; //设置标志位，初始化为false\n        for (uint256 i = 0; i < len - 1; ++i) {\n            //外层循环n-1次；\n            for (uint256 j = 0; j < len - 1 - i; ++j) {\n                //每次循环完，都能从剩下的数组中找出个最大的数组放在 len-1-i 的位置；\n                if (tempArr[j] > tempArr[j + 1]) {\n                    temp = tempArr[j];\n                    tempArr[j] = tempArr[j + 1];\n                    tempArr[j + 1] = temp;\n                    flag = true; //如果交换好了，做个标记，避免无效的循环；\n                }\n            }\n            if (!!flag) {\n                //只要交换了位置，flag的值就重新设置为false了；\n                flag = false;\n            } else {\n                //如果没有交换，说明数组已经排好序了，可以结束循环了；\n                break;\n            }\n        }\n        return tempArr;\n    }\n}\n")])])]),e("h2",{attrs:{id:"🆗-实战应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#🆗-实战应用"}},[n._v("#")]),n._v(" 🆗 实战应用")]),n._v(" "),e("p",[n._v("快速排序和数组去重作为扩展练习，自己可以动手实现。")]),n._v(" "),e("ul",[e("li",[n._v("实现快速排序")]),n._v(" "),e("li",[n._v("实现数组去重")])]),n._v(" "),e("h2",{attrs:{id:"️⃣-问答题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#️⃣-问答题"}},[n._v("#")]),n._v(" #️⃣ 问答题")]),n._v(" "),e("ul",[e("li",[n._v("插入排序的写法"),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("  function insertSort(uint256[] calldata ary)\n  public\n  pure\n  returns (uint256[] memory)\n  {\n      uint256[] memory tempArr = ary;\n      uint256 temp; //定义一个临时变量，保存要插入的值；\n      uint256 len = tempArr.length;\n      uint256 pIndex; // 上一个值\n      for (uint256 i = 1; i < len; ++i) {\n          temp = tempArr[i]; //需要插入的值；\n          pIndex = i;\n          while (pIndex >= 1 && temp < tempArr[pIndex - 1]) {\n              tempArr[pIndex] = tempArr[pIndex - 1]; //相当于ary[i]=ary[i-1];\n              --pIndex; //准备下一波交换；\n          }\n          tempArr[pIndex] = temp; //相当于ary[i-1]=temp; 因为上面 pIndex-- 了\n      }\n      return tempArr;\n  }\n")])])]),e("ul",[e("li",[e("code",[n._v("if (ary[i] < ary[i - 1])")]),n._v(" 与 "),e("code",[n._v("temp < ary[pIndex - 1]")]),n._v(" 重复判断了")]),n._v(" "),e("li",[n._v("输入变量的位置 memory，可以改为 "),e("code",[n._v("calldata")])]),n._v(" "),e("li",[e("code",[n._v("i++")]),n._v(" 可以改为 "),e("code",[n._v("++")]),n._v(";")]),n._v(" "),e("li",[e("code",[n._v("pIndex--;")]),n._v(" 可以改为 "),e("code",[n._v("--pIndex;")])]),n._v(" "),e("li",[n._v("内部声明的所有变量，都可以提到循环外")])])])])])}),[],!1,null,null,null);e.default=a.exports}}]);