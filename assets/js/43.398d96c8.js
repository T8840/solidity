(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{452:function(t,s,a){"use strict";a.r(s);var n=a(2),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"_17-metadata-元数据"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_17-metadata-元数据"}},[t._v("#")]),t._v(" 17.metadata:元数据")]),t._v(" "),s("p",[t._v("Solidity 编译器在编译的时候自动生成"),s("code",[t._v("xx_metadata.json")]),t._v("的 JSON 文件，中文叫合约的元数据，其中包含了当前合约的相关信息。")]),t._v(" "),s("h2",{attrs:{id:"_1️⃣-metadata-包含信息"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1️⃣-metadata-包含信息"}},[t._v("#")]),t._v(" 1️⃣ metadata 包含信息")]),t._v(" "),s("p",[t._v("元数据文件具有以下格式。 下面的例子将以人类可读的方式呈现。正确格式化的元数据应正确使用引号，将空白减少到最小，并对所有对象的键值进行排序以得到唯一的格式。（下面的代码注释是不允许的，这里仅用于解释目的。）")]),t._v(" "),s("div",{staticClass:"language-json extra-class"},[s("pre",{pre:!0,attrs:{class:"language-json"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 必选：元数据格式的版本(注意和Solidity版本不是同一个version )")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"version"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 必选：源代码的编程语言，一般会选择规范的“子版本”")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"language"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Solidity"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 必选：编译器的细节，内容视语言而定。")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"compiler"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对 Solidity 来说是必须的：编译器的版本")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"version"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0.8.7+commit.e28d00a7"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 可选： 生成此输出的编译器二进制文件的哈希值")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"keccak256"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x123..."')]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 必选：合约的生成信息")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"output"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 必选：合约的 ABI 定义")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"abi"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*...*/")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 必选：合约的 NatSpec 用户文档")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"userdoc"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*...*/")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 必选：合约的 NatSpec 开发者文档")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"devdoc"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*...*/")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 必选：编译器的设置")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"settings"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"compilationTarget"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"a.sol"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Sum"')]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"evmVersion"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"london"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"libraries"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"metadata"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Reflects the setting used in the input json, defaults to false")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"useLiteralContent"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// Reflects the setting used in the input json, defaults to "ipfs"')]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"bytecodeHash"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"ipfs"')]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 可选： 优化器的设置（ enabled 默认设为 false ）")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"optimizer"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"enabled"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"runs"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("200")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对 Solidity 来说是必须的： 已排序的重定向列表")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"remappings"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('":g/dir"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 必选：编译的源文件／源单位，键值为文件名")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"sources"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"myFile.sol"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 必选：源文件的 keccak256 哈希值")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"keccak256"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x123..."')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Optional: 在源文件中定义的 SPDX license 标识")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"license"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"MIT"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 必选（除非定义了 content，详见下文）：")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 已排序的源文件的URL，URL的协议可以是任意的，但建议使用 Swarm 的URL")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"urls"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"bzz-raw://fd33d..."')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"dweb:/ipfs/Qme8Vrt"')]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 可选")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"mortal"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 必选：源文件的 keccak256 哈希值")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"keccak256"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x234..."')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 必选（除非定义了“urls”）： 源文件的字面内容")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"content"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(' "contract mortal is owned '),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" function kill() "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        if (msg.sender == owner) selfdestruct(owner); "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v('"\n    '),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"metadata-的作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#metadata-的作用"}},[t._v("#")]),t._v(" metadata 的作用")]),t._v(" "),s("p",[t._v("metadata 主要是为了更安全地与合约进行交互并验证其源代码。")]),t._v(" "),s("ul",[s("li",[t._v("查询编译器版本")]),t._v(" "),s("li",[t._v("所使用的源代码")]),t._v(" "),s("li",[t._v("ABI")]),t._v(" "),s("li",[t._v("natspec 文档")])]),t._v(" "),s("p",[t._v("编译器会将元数据文件的 Swarm 哈希值附加到每个合约的字节码末尾（详情请参阅下文），以便你可以以认证的方式获取该文件，而不必求助于中心化的数据提供者。当然，你必须将元数据文件发布到 Swarm（或其他服务），以便其他人可以访问它。 该文件可以通过使用"),s("code",[t._v("solc --metadata")]),t._v(" 来生成，并被命名为 "),s("code",[t._v("ContractName_meta.json")]),t._v(" 。 它将包含源代码的在 Swarm 上的引用，因此你必须上传所有源文件和元数据文件。")]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("⚠️ 警告: 由于生成的合约的字节码包含元数据的哈希值，因此对元数据的任何更改都会导致字节码的更改。\n此外，由于元数据包含所有使用的源代码的哈希值，所以任何源代码中的，哪怕是一个空格的变化都将导致不同的元数据，并随后产生不同的字节代码。")]),t._v(" "),s("p",[t._v("⚠️ 警告: 需注意，上面的 ABI 没有固定的顺序，随编译器的版本而不同。")]),t._v(" "),s("h2",{attrs:{id:"_2️⃣-字节码中元数据哈希的编码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2️⃣-字节码中元数据哈希的编码"}},[t._v("#")]),t._v(" 2️⃣ 字节码中元数据哈希的编码")]),t._v(" "),s("p",[t._v("由于在将来可能会支持其他方式来获取元数据文件， 类似"),s("code",[t._v('{"bzzr0"：<Swarm hash>}')]),t._v(" 的键值对，将会以\nCBOR ("),s("a",{attrs:{href:"https://tools.ietf.org/html/rfc7049",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://tools.ietf.org/html/rfc7049"),s("OutboundLink")],1),t._v(") 编码来存储。由于这种编码的起始位不容易找到，因此添加两个字节来表述其长度，以大端方式编码。所以，当前版本的 Solidity 编译器，将以下内容添加到部署的字节码的末尾")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("    0xa2\n    0x64 'i' 'p' 'f' 's' 0x58 0x22 <34 bytes IPFS hash>\n    0x64 's' 'o' 'l' 'c' 0x43 <3 byte version encoding>\n    0x00 0x33\n")])])]),s("p",[t._v("因此，为了检索数据，可以检查已部署字节码的末尾以匹配该模式，并使用 IPFS 哈希来检索文件。")]),t._v(" "),s("p",[t._v("solc 的发布版本使用如上所示的版本的 3 字节编码（major, minor and patch version number 版本号各一个字节），而预发布版本将使用完整的版本字符串，包括提交哈希和构建日期。")]),t._v(" "),s("p",[t._v("CBOR 映射还可以包含其他密钥，因此最好完全解码数据而不是依赖以 "),s("code",[t._v("0xa264")]),t._v(" 开头的数据。 例如，如果使用任何影响代码生成的实验性功能，则映射也将包含 "),s("code",[t._v('"experimental"：true')]),t._v("。")]),t._v(" "),s("p",[t._v("编译器目前默认使用元数据的 IPFS 哈希，但将来也可能使用 bzzr1 哈希或其他一些哈希，因此不要依赖此序列以 "),s("code",[t._v("0xa2 0x64 'i' 'p' 'f' 's'")]),t._v(" 开头 的。 我们可能还会向此 CBOR 结构中添加其他数据，因此最好的选择是使用适当的 CBOR 解析器。")]),t._v(" "),s("h2",{attrs:{id:"_3️⃣-自动化接口生成和-natspec-使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3️⃣-自动化接口生成和-natspec-使用"}},[t._v("#")]),t._v(" 3️⃣ 自动化接口生成和 natspec 使用")]),t._v(" "),s("p",[t._v("元数据以下列方式使用：通过钱包想要与合约交互时检索合约代码，然后检索文件的 IPFS/Swarm 哈希。该文件被 JSON 解码为上面的结构。")]),t._v(" "),s("p",[t._v("组件可以使用 ABI 自动为合约生成一个基本的用户界面。")]),t._v(" "),s("p",[t._v("此外，钱包可以使用 NatSpec 用户文档，在用户与合约交互，授权请求签名时候做辅助工作。")]),t._v(" "),s("h2",{attrs:{id:"_4️⃣-源代码如何验证"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4️⃣-源代码如何验证"}},[t._v("#")]),t._v(" 4️⃣ 源代码如何验证？")]),t._v(" "),s("p",[t._v("为了验证编译，可以通过元数据文件中的链接从 IPFS/Swarm 中获取源代码。获取到的源码，会根据元数据中指定的设置，被正确版本的编译器所处理。处理得到的字节码会与创建交易的数据或者 "),s("code",[t._v("CREATE")]),t._v(" 操作码使用的数据进行比较。这会自动验证元数据，因为它的哈希值是字节码的一部分。而额外的数据，则是与基于接口进行编码并展示给用户的构造输入数据相符的。")]),t._v(" "),s("p",[t._v("在 "),s("a",{attrs:{href:"https://github.com/ethereum/sourcify",target:"_blank",rel:"noopener noreferrer"}},[t._v("sourcify"),s("OutboundLink")],1),t._v(" 库("),s("a",{attrs:{href:"https://www.npmjs.com/package/source-verify",target:"_blank",rel:"noopener noreferrer"}},[t._v("npm package"),s("OutboundLink")],1),t._v(")可以看到如何使用该特性的示例代码。")]),t._v(" "),s("h2",{attrs:{id:"🆗-实战应用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#🆗-实战应用"}},[t._v("#")]),t._v(" 🆗 实战应用")]),t._v(" "),s("h2",{attrs:{id:"️⃣-问答题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#️⃣-问答题"}},[t._v("#")]),t._v(" #️⃣ 问答题")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("metadata 的作用是什么？")]),t._v(" "),s("ul",[s("li",[t._v("metadata 主要是为了更安全地与合约进行交互并验证其源代码。")]),t._v(" "),s("li",[t._v("查询编译器版本")]),t._v(" "),s("li",[t._v("所使用的源代码")]),t._v(" "),s("li",[t._v("ABI")]),t._v(" "),s("li",[t._v("natspec 文档")])])]),t._v(" "),s("li",[s("p",[t._v("metadata 内容有哪些？")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('{\n  // 必选：元数据格式的版本(注意和Solidity版本不是同一个version )\n  "version": "1",\n\n  // 必选：源代码的编程语言，一般会选择规范的“子版本”\n  "language": "Solidity",\n\n  // 必选：编译器的细节，内容视语言而定。\n  "compiler": {\n    // 对 Solidity 来说是必须的：编译器的版本\n    "version": "0.8.7+commit.e28d00a7",\n  },\n\n  // 必选：合约的生成信息\n  "output": {\n    // 必选：合约的 ABI 定义\n    "abi": [ /*...*/],\n    // 必选：合约的 NatSpec 用户文档\n    "userdoc": [ /*...*/],\n    // 必选：合约的 NatSpec 开发者文档\n    "devdoc": [ /*...*/],\n  },\n\n  // 必选：编译器的设置\n  "settings": {},\n\n  // 必选：编译的源文件／源单位，键值为文件名\n  "sources": {\n    "myFile.sol": {\n      // 必选：源文件的 keccak256 哈希值\n      "keccak256": "0x123...",\n\n      // Optional: 在源文件中定义的 SPDX license 标识\n      "license": "MIT",\n    }\n  },\n}\n')])])])]),t._v(" "),s("li",[s("p",[t._v("natspec 如何使用？")])]),t._v(" "),s("li",[s("p",[t._v("源代码如何验证？")]),t._v(" "),s("ul",[s("li",[t._v("为了验证编译，可以通过元数据文件中的链接从 IPFS/Swarm 中获取源代码。获取到的源码，会根据元数据中指定的设置，被正确版本的编译器所处理。处理得到的字节码会与创建交易的数据或者 "),s("code",[t._v("CREATE")]),t._v(" 操作码使用的数据进行比较。这会自动验证元数据，因为它的哈希值是字节码的一部分。而额外的数据，则是与基于接口进行编码并展示给用户的构造输入数据相符的。")]),t._v(" "),s("li",[t._v("在 "),s("a",{attrs:{href:"https://github.com/ethereum/sourcify",target:"_blank",rel:"noopener noreferrer"}},[t._v("sourcify"),s("OutboundLink")],1),t._v(" 库("),s("a",{attrs:{href:"https://www.npmjs.com/package/source-verify",target:"_blank",rel:"noopener noreferrer"}},[t._v("npm package"),s("OutboundLink")],1),t._v(")可以看到如何使用该特性的示例代码。")])])])])])}),[],!1,null,null,null);s.default=e.exports}}]);